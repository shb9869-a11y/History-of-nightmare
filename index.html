<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,interactive-widget=resizes-content">
<title>From Emptiness (空) to Togetherness (共)</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="LIMEN">
<meta name="theme-color" content="#000000">

<!-- ✅ BOX DETECT libs -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>

<style>
:root{
  --frame: clamp(16px, 4vmin, 40px);
  --ui-gap: 8px;
  --fs-strong: clamp(14px, 2.8vmin, 18px);
  --fs-small: clamp(11px, 1.8vmin, 13px);
  --pad-btn-y: clamp(8px, 1.1vmin, 12px);
  --pad-btn-x: clamp(12px, 1.8vmin, 20px);
  --safe-t: env(safe-area-inset-top, 0px);
  --safe-b: env(safe-area-inset-bottom, 0px);
  --safe-l: env(safe-area-inset-left, 0px);
  --safe-r: env(safe-area-inset-right, 0px);

  /* ✅ palette */
  --ink: #0a0a0a;
  --paper: #e7e2c9; /* warm off-white like your ref */
  --paper-dim: rgba(231,226,201,.72);
  --line: rgba(231,226,201,.62);
  --line-2: rgba(231,226,201,.26);
  --accent-red: rgba(180,60,50,.75);
}

html,body{
  margin:0; padding:0; width:100%; height:100%;
  background:#000; overflow:hidden;
  touch-action:manipulation;
}
body{
  font-family: ui-serif, "Iowan Old Style", "Palatino Linotype", Palatino,
               "Times New Roman", Times, serif;
  -webkit-user-select:none; user-select:none;
  -webkit-touch-callout:none;
  color:var(--paper);
}
*{
  box-sizing:border-box;
  -webkit-user-select:none; user-select:none;
  -webkit-touch-callout:none;
  -webkit-tap-highlight-color: transparent;
}

.fade{opacity:0; transition:opacity 1100ms ease}
.fade.show{opacity:1}

#bg{
  position:fixed; inset:0;
  width:100vw; height:100vh;
  display:block;
  z-index:0;
  background:#000;
}

#view{
  position:fixed; inset:0;
  width:100vw; height:100vh;
  display:block; z-index:2;
  filter:grayscale(1);
}

#freezeLayer{
  position:fixed; inset:0;
  z-index:500;
  display:none;
}

/* frame */
.frameBox{
  position:fixed;
  left:calc(var(--frame) + var(--safe-l));
  top:calc(var(--frame) + var(--safe-t));
  right:calc(var(--frame) + var(--safe-r));
  bottom:calc(var(--frame) + var(--safe-b));
  border:1.5px solid rgba(231,226,201,.68);
  pointer-events:none;
  z-index:50;
}

/* capture / status */
.uiBtn{
  background:transparent;
  color:var(--paper);
  border:none;
  font-size:var(--fs-strong);
  padding:var(--pad-btn-y) var(--pad-btn-x);
  font-family: inherit;
  letter-spacing: .10em;
  white-space:nowrap;
  cursor:pointer;
  opacity:.92;
}
.uiBtn.small{
  font-size:var(--fs-small);
  padding:calc(var(--pad-btn-y)*0.75) calc(var(--pad-btn-x)*0.75);
}
.uiBtn:active{opacity:.75; transform:translateY(1px);}
.uiBtn[disabled]{ opacity:.35; pointer-events:none; filter:grayscale(1); }

.controls{
  position:fixed;
  right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
  bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
  z-index:400;
  display:flex;
  gap:6px;
  align-items:center;
  opacity:0;
  transition:opacity 1100ms ease;
}
.controls.show{opacity:1}
.readout{
  min-width:64px;
  text-align:center;
  opacity:.85;
  font-size:var(--fs-small);
  color:var(--paper);
  font-family: inherit;
}

.btn-capture{
  position:fixed;
  left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
  bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
  z-index:450;
  opacity:0;
  transition:opacity 1100ms ease;
}
.btn-capture.show{opacity:1}

.sleep-status-text{
  position:fixed;
  left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
  bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b) + 34px);
  z-index:451;
  font-size:var(--fs-small);
  color:var(--paper-dim);
  text-shadow:0 0 6px rgba(0,0,0,0.7);
  max-width:min(76vw, 720px);
  letter-spacing:.08em;
}

/* =========================
   ✅ Overlays: permission / title
   ========================= */
#overlayStack{
  position:fixed; inset:0;
  z-index:300;
  display:block;
  pointer-events:auto;
}

.scene{
  position:absolute; inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:calc(28px + var(--safe-t)) calc(26px + var(--safe-r)) calc(26px + var(--safe-b)) calc(26px + var(--safe-l));
  background:radial-gradient(1200px 700px at 50% 40%, rgba(255,255,255,.06), rgba(0,0,0,.86));
}
.scene.hidden{display:none;}

.scene .content{
  width:min(92vw, 980px);
  text-align:left;
}

.kicker{
  display:flex;
  align-items:baseline;
  gap:12px;
  letter-spacing:.14em;
  font-size:clamp(12px, 2.0vmin, 14px);
  color:var(--paper-dim);
}
.kicker .mark{
  color:var(--accent-red);
  letter-spacing:.22em;
}

.title{
  margin-top:18px;
  font-size:clamp(34px, 5.4vmin, 66px);
  line-height:1.08;
  letter-spacing:.02em;
  color:var(--paper);
}
.sub{
  margin-top:14px;
  font-size:clamp(14px, 2.4vmin, 18px);
  line-height:1.55;
  letter-spacing:.06em;
  color:var(--paper-dim);
}

.tapHint{
  margin-top:28px;
  font-size:clamp(12px, 2.0vmin, 14px);
  letter-spacing:.12em;
  color:rgba(231,226,201,.70);
}

/* =========================
   ✅ BOX DETECT UI - right vertical panel
   (MENU button: NO white rounded frame)
   ========================= */
#toggleUI{
  position:fixed;
  right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
  top:calc(var(--frame) + var(--ui-gap) + var(--safe-t));
  z-index:920;
  background:transparent;
  border:none;
  padding:0;
  color:var(--paper);
  letter-spacing:.16em;
  font-family: inherit;
  opacity:.85;
  cursor:pointer;
}
#toggleUI:active{opacity:.62; transform:translateY(1px);}

#ui{
  position:fixed;
  right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
  top:calc(var(--frame) + var(--ui-gap) + var(--safe-t) + 34px);
  z-index:910;

  width:min(300px, calc(100vw - (var(--frame)*2) - 24px));
  max-height:calc(100vh - (var(--frame)*2) - 120px);
  overflow:auto;

  background:rgba(0,0,0,.38);
  border:1px solid rgba(231,226,201,.12);
  border-radius:18px;
  padding:12px;
  backdrop-filter: blur(10px);

  display:flex;
  flex-direction:column;
  gap:10px;
  pointer-events:auto;
  transition:.2s;

  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}
#ui.hidden{opacity:0; pointer-events:none; transform:translateY(-10px);}

.pill{
  display:grid;
  grid-template-columns: 92px 1fr auto;
  gap:10px;
  align-items:center;
  background:rgba(255,255,255,.045);
  border:1px solid rgba(231,226,201,.10);
  border-radius:16px;
  padding:10px 12px;
  color:#ddd;
}
.pill b{color:#fff; font-weight:800; letter-spacing:.12em;}
.pill input[type=range]{width:100%;}
.pill label{
  grid-column: 1 / -1;
  display:flex;
  align-items:center;
  gap:10px;
}
#ui button{
  appearance:none;
  border:1px solid rgba(231,226,201,.14);
  background:rgba(255,255,255,.06);
  color:#fff;
  padding:10px 12px;
  border-radius:14px;
  font-weight:800;
  pointer-events:auto;
}
#ui button:active{transform:translateY(1px);}

#log{
  position:fixed;
  left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
  top:calc(var(--frame) + var(--ui-gap) + var(--safe-t));
  z-index:905;
  font-size:11px;
  background:rgba(0,0,0,.18);
  border:1px solid rgba(231,226,201,.08);
  border-radius:12px;
  padding:6px 10px;
  backdrop-filter: blur(10px);
  max-width:min(86vw,820px);
  white-space:pre-wrap;
  pointer-events:none;
  color:rgba(231,226,201,.75);
  opacity:0;
  transition:opacity 900ms ease;
  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}
#log.show{opacity:.55;}
</style>
</head>

<body>
  <!-- ✅ dreamy point-line background -->
  <canvas id="bg"></canvas>

  <!-- main output -->
  <canvas id="view"></canvas>
  <canvas id="freezeLayer"></canvas>

  <div class="frameBox" aria-hidden="true"></div>

  <div class="controls" id="controls">
    <button class="uiBtn small" id="zoomOut">–</button>
    <div class="readout"><span id="zoomVal">1.0×</span></div>
    <button class="uiBtn small" id="zoomIn">+</button>
  </div>

  <button id="captureBtn" class="uiBtn small btn-capture">Capture</button>
  <div id="sleepPhotoStatus" class="sleep-status-text"></div>

  <!-- ✅ BOX DETECT UI -->
  <button id="toggleUI">MENU</button>
  <div id="ui" class="hidden">
    <div class="pill">
      <b>COARSE</b>
      <input id="conf" type="range" min="0.01" max="0.95" step="0.01" value="0.12">
      <span id="confVal">0.12</span>
    </div>

    <div class="pill">
      <b>FINE</b>
      <input id="fine" type="range" min="0.00" max="1.00" step="0.01" value="0.40">
      <span id="fineVal">0.40</span>
    </div>

    <div class="pill">
      <b>N</b>
      <input id="topN" type="range" min="3" max="8" step="1" value="4">
      <span id="topNVal">4</span>
    </div>

    <div class="pill">
      <b>HOLD</b>
      <input id="holdSec" type="range" min="1" max="10" step="0.5" value="3.0">
      <span id="holdVal">3.0s</span>
    </div>

    <div class="pill">
      <b>BOX</b>
      <input id="boxScale" type="range" min="0.35" max="1.20" step="0.01" value="0.88">
      <span id="boxScaleVal">0.88</span>
    </div>

    <div class="pill">
      <label><input id="links" type="checkbox" checked> Links</label>
      <label><input id="fillFrag" type="checkbox" checked> Fragments</label>
    </div>

    <div class="pill" style="grid-template-columns: 1fr 1fr; gap:10px;">
      <button id="flip">Flip</button>
      <button id="restart">Restart</button>
    </div>

    <div class="pill" style="grid-template-columns: 92px 1fr; gap:10px;">
      <b>Source</b>
      <div style="display:flex; gap:10px; align-items:center; justify-content:flex-end;">
        <label style="display:flex; align-items:center; gap:8px;">
          <input id="videoFile" type="file" accept="video/*" style="max-width:160px;">
          <span style="opacity:.9">Upload</span>
        </label>
        <button id="useCam">Camera</button>
      </div>
    </div>

    <div class="pill" style="grid-template-columns: 1fr; gap:6px;">
      <span id="status">Idle</span>
      <span id="fps">FPS -</span>
      <span id="count">Boxes 0</span>
    </div>
  </div>

  <div id="log">ready</div>

  <!-- ✅ overlay stack: tap-to-permission → fade → title → tap-to-enter -->
  <div id="overlayStack" class="fade show">
    <!-- scene 1: permission -->
    <div id="scenePerm" class="scene">
      <div class="content">
        <div class="kicker"><span class="mark">□</span> CAMERA PERMISSION</div>
        <div class="title">Tap anywhere</div>
        <div class="sub">to allow camera access.</div>
        <div class="tapHint">— tap to continue</div>
      </div>
    </div>

    <!-- scene 2: title -->
    <div id="sceneTitle" class="scene hidden">
      <div class="content">
        <div class="kicker"><span class="mark">□</span> TITLE &amp; CONCEPT FRAME</div>
        <div class="title">From&nbsp;Emptiness&nbsp;(空)&nbsp;&nbsp;to&nbsp;Togetherness&nbsp;(共)</div>
        <div class="sub">A Cooking–Memory–Spatial Experiment in Reconstructing Empathy</div>
        <div class="tapHint">Tap to participate.</div>
      </div>
    </div>
  </div>

<script>
(() => {
  /* =========================
     ✅ 업로드 서버 설정
     ========================= */
  const SLEEP_UPLOAD_SERVER = 'https://172.16.14.60:4443'; // <-- 네 서버
  const UPLOAD_TIMEOUT_MS = 12000;
  const UPLOAD_RETRY = 1;

  const FADE = 1100;
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const qs = s => document.querySelector(s);
  const lerp=(a,b,t)=>a+(b-a)*t;
  const lerpBox=(cur,target,t)=>[lerp(cur[0],target[0],t),lerp(cur[1],target[1],t),lerp(cur[2],target[2],t),lerp(cur[3],target[3],t)];

  function fadeToScene(fromEl, toEl){
    // fade out stack content slightly, swap, fade in
    const stack = qs('#overlayStack');
    stack.style.transition = `opacity ${FADE}ms ease`;
    stack.style.opacity = '0';
    setTimeout(()=>{
      fromEl.classList.add('hidden');
      toEl.classList.remove('hidden');
      stack.style.opacity = '1';
    }, Math.round(FADE*0.65));
  }
  function fadeOutOverlay(){
    const stack = qs('#overlayStack');
    stack.style.transition = `opacity ${FADE}ms ease`;
    stack.style.opacity = '0';
    setTimeout(()=>{ stack.style.display='none'; }, FADE);
  }

  document.addEventListener('contextmenu', e=>e.preventDefault());
  document.addEventListener('selectstart', e=>e.preventDefault());

  /* =========================
     subtle click sfx (kept)
     ========================= */
  let audioCtx = null;
  function ensureAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  async function ensureResumed(){
    ensureAudio();
    if(audioCtx.state === 'suspended'){
      try{ await audioCtx.resume(); }catch(e){}
    }
  }
  const MASTER_SFX_GAIN = 0.18;
  async function playClick(){
    try{
      await ensureResumed();
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type='sine';
      o.frequency.setValueAtTime(190, now);
      o.frequency.exponentialRampToValueAtTime(140, now+0.12);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(MASTER_SFX_GAIN, now+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now+0.18);
      o.connect(g).connect(audioCtx.destination);
      o.start(now);
      o.stop(now+0.2);
    }catch(e){}
  }

  /* =========================
     DOM
     ========================= */
  const scenePerm = qs('#scenePerm');
  const sceneTitle = qs('#sceneTitle');
  const overlayStack = qs('#overlayStack');

  const controls = qs('#controls');
  const zoomIn = qs('#zoomIn');
  const zoomOut = qs('#zoomOut');
  const zoomVal = qs('#zoomVal');
  const captureBtn = qs('#captureBtn');

  const bg = qs('#bg');
  const view = qs('#view');
  const freezeLayer = qs('#freezeLayer');

  const sleepPhotoStatus = qs('#sleepPhotoStatus');
  function setSleepPhotoStatus(msg){ sleepPhotoStatus.textContent = msg || ''; }

  const toggleUIBtn = qs('#toggleUI');
  const ui = qs('#ui');
  const logEl = qs('#log');

  const confEl = qs('#conf');
  const confVal = qs('#confVal');
  const fineEl = qs('#fine');
  const fineVal = qs('#fineVal');
  const topNEl = qs('#topN');
  const topNVal = qs('#topNVal');
  const holdSecEl = qs('#holdSec');
  const holdValEl = qs('#holdVal');
  const boxScaleEl = qs('#boxScale');
  const boxScaleValEl = qs('#boxScaleVal');

  const linksEl = qs('#links');
  const fillFragEl = qs('#fillFrag');

  const flipBtn = qs('#flip');
  const restartBtn = qs('#restart');
  const useCamBtn = qs('#useCam');
  const videoFileEl = qs('#videoFile');

  const statusEl = qs('#status');
  const fpsEl = qs('#fps');
  const countEl = qs('#count');

  function log(msg){ logEl.textContent = String(msg); }

  toggleUIBtn.addEventListener('click', ()=>{
    const hidden = ui.classList.toggle('hidden');
    toggleUIBtn.textContent = hidden ? 'MENU' : 'CLOSE';
    playClick();
  }, {passive:true});

  /* =========================
     ✅ Background: points & lines (dream)
     ========================= */
  const bctx = bg.getContext('2d', { alpha:false });

  const bgState = {
    pts: [],
    seed: Math.random()*9999,
    t0: performance.now(),
    swirl: 0,
    pulse: 0
  };

  function resizeCanvas(c){
    const dpr = window.devicePixelRatio || 1;
    const w = innerWidth, h = innerHeight;
    c.width = Math.round(w * dpr);
    c.height = Math.round(h * dpr);
    const ctx = c.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  function resizeAll(){
    resizeCanvas(bg);
    const dpr=window.devicePixelRatio||1;
    const w=window.innerWidth;
    const h=window.innerHeight;
    view.width=w*dpr;
    view.height=h*dpr;
    const vctx = view.getContext('2d', { alpha:false });
    vctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resizeAll, {passive:true});
  window.addEventListener('orientationchange', resizeAll, {passive:true});
  resizeAll();

  function initBgPoints(){
    const W = innerWidth, H = innerHeight;
    const n = Math.round(clamp((W*H)/11000, 60, 140));
    bgState.pts = [];
    for(let i=0;i<n;i++){
      bgState.pts.push({
        x: Math.random()*W,
        y: Math.random()*H,
        vx: (Math.random()-0.5)*0.20,
        vy: (Math.random()-0.5)*0.20,
        r: 0.6 + Math.random()*1.4,
        k: Math.random()*6.28
      });
    }
  }
  initBgPoints();

  function bgLoop(){
    const W = innerWidth, H = innerHeight;
    const t = (performance.now() - bgState.t0) * 0.001;

    // slow pulse to feel "sound-ish" without mic permission
    bgState.pulse = 0.5 + 0.5*Math.sin(t*0.65);
    bgState.swirl = 0.35*Math.sin(t*0.23);

    // background fill
    bctx.fillStyle = '#000';
    bctx.fillRect(0,0,W,H);

    // points drift + slight vortex
    const cx = W*0.52, cy = H*0.46;
    for(const p of bgState.pts){
      const dx = p.x - cx, dy = p.y - cy;
      const ang = Math.atan2(dy, dx) + bgState.swirl*0.35;
      const pull = 0.0006 * (0.6 + bgState.pulse);

      p.vx += -Math.cos(ang+Math.PI/2) * pull * (Math.abs(dx)+120);
      p.vy += -Math.sin(ang+Math.PI/2) * pull * (Math.abs(dy)+120);

      // idle breathing motion
      p.vx += 0.03*Math.sin(t*0.9 + p.k) * 0.02;
      p.vy += 0.03*Math.cos(t*0.8 + p.k) * 0.02;

      // damping
      p.vx *= 0.985;
      p.vy *= 0.985;

      p.x += p.vx;
      p.y += p.vy;

      // wrap
      if(p.x < -20) p.x = W+20;
      if(p.x > W+20) p.x = -20;
      if(p.y < -20) p.y = H+20;
      if(p.y > H+20) p.y = -20;
    }

    // lines (kNN-ish via threshold)
    const maxDist = Math.min(W,H) * (0.18 + 0.07*bgState.pulse);
    const maxD2 = maxDist*maxDist;

    bctx.save();
    bctx.globalCompositeOperation = 'lighter';

    for(let i=0;i<bgState.pts.length;i++){
      const a = bgState.pts[i];
      for(let j=i+1;j<bgState.pts.length;j++){
        const b = bgState.pts[j];
        const dx = a.x-b.x, dy = a.y-b.y;
        const d2 = dx*dx+dy*dy;
        if(d2 > maxD2) continue;

        const d = Math.sqrt(d2);
        const alpha = clamp(1 - (d/maxDist), 0, 1);
        const w = 0.6 + alpha*0.9;

        bctx.lineWidth = w;
        bctx.strokeStyle = `rgba(231,226,201,${(0.05 + 0.18*alpha).toFixed(3)})`;
        bctx.beginPath();
        bctx.moveTo(a.x, a.y);
        bctx.lineTo(b.x, b.y);
        bctx.stroke();
      }
    }

    // points
    for(const p of bgState.pts){
      const glow = 0.22 + 0.55*bgState.pulse;
      bctx.fillStyle = `rgba(231,226,201,${(0.18*glow).toFixed(3)})`;
      bctx.beginPath();
      bctx.arc(p.x, p.y, p.r*(0.9+0.35*bgState.pulse), 0, Math.PI*2);
      bctx.fill();
    }

    // subtle red mark somewhere (very faint)
    const rx = W*0.11, ry = H*0.12;
    bctx.fillStyle = `rgba(180,60,50,${(0.05 + 0.05*bgState.pulse).toFixed(3)})`;
    bctx.fillRect(rx, ry, 10, 10);

    bctx.restore();

    requestAnimationFrame(bgLoop);
  }
  requestAnimationFrame(bgLoop);

  /* =========================
     캔버스/카메라
     ========================= */
  const vctx = view.getContext('2d', { alpha:false });

  let camStream=null;
  let camVideo=null;
  let facingMode='environment';
  let usingUploadVideo=false;

  let ZOOM=1.0;
  let showCamera=false;
  let camFadeAlpha=0;

  function updateZoomLabel(){ zoomVal.textContent = ZOOM.toFixed(1)+'×'; }
  updateZoomLabel();

  zoomIn.addEventListener('click', async ()=>{
    await ensureResumed();
    ZOOM=Math.min(3.0, ZOOM+0.1);
    updateZoomLabel();
    playClick();
  }, {passive:true});

  zoomOut.addEventListener('click', async ()=>{
    await ensureResumed();
    ZOOM=Math.max(1.0, ZOOM-0.1);
    updateZoomLabel();
    playClick();
  }, {passive:true});

  async function startCameraFresh(){
    usingUploadVideo=false;
    if (camStream){
      camStream.getTracks().forEach(t=>t.stop());
      camStream=null;
    }
    const s = await navigator.mediaDevices.getUserMedia({
      video:{
        facingMode:{ideal:facingMode},
        width:{min:1280,ideal:1920},
        height:{min:720,ideal:1080},
        aspectRatio:{ideal:16/9}
      },
      audio:false
    });
    camStream = s;

    if(!camVideo){
      camVideo=document.createElement('video');
      camVideo.setAttribute('playsinline','');
      camVideo.autoplay=true;
      camVideo.playsInline=true;
      camVideo.muted=true;
    }
    camVideo.srcObject=camStream;
    camVideo.src = '';
    await camVideo.play().catch(()=>{});
    if (camVideo.readyState < 1){
      await new Promise(res=>camVideo.addEventListener('loadedmetadata', res, {once:true}));
    }
  }

  async function useUploadedVideo(file){
    usingUploadVideo=true;
    if (camStream){
      camStream.getTracks().forEach(t=>t.stop());
      camStream=null;
    }
    if(!camVideo){
      camVideo=document.createElement('video');
      camVideo.setAttribute('playsinline','');
      camVideo.autoplay=true;
      camVideo.playsInline=true;
      camVideo.muted=true;
    }
    camVideo.srcObject=null;
    camVideo.loop=true;
    camVideo.muted=true;
    camVideo.src = URL.createObjectURL(file);
    await camVideo.play().catch(()=>{});
    if (camVideo.readyState < 1){
      await new Promise(res=>camVideo.addEventListener('loadedmetadata', res, {once:true}));
    }
  }

  function fadeInCamera(dur=900){
    showCamera = true;
    const start = performance.now();
    camFadeAlpha = 0;
    function step(){
      const t = (performance.now() - start) / dur;
      camFadeAlpha = clamp(t, 0, 1);
      if(t < 1 && showCamera) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  function getCameraDrawTransform(){
    const w = view.clientWidth || innerWidth;
    const h = view.clientHeight || innerHeight;

    if(!camVideo || camVideo.readyState < 2) return null;
    const vw = camVideo.videoWidth, vh = camVideo.videoHeight;
    if(!vw || !vh) return null;

    const fw = w, fh = h;
    const videoRatio = vw / vh;
    const frameRatio = fw / fh;

    let dw, dh;
    if(videoRatio > frameRatio){ dh = fh; dw = dh * videoRatio; }
    else { dw = fw; dh = dw / videoRatio; }

    dw *= ZOOM; dh *= ZOOM;
    const dx = (fw - dw)/2;
    const dy = (fh - dh)/2;

    return { vw, vh, dx, dy, dw, dh, fw, fh };
  }

  /* =========================
     ✅ 업로드: 리사이즈 + 타임아웃 + 재시도
     ========================= */
  function humanErr(e){
    const msg = (e && e.message) ? e.message : String(e);
    if (/aborted/i.test(msg)) return "timeout";
    return msg;
  }

  async function canvasToJpegBlobResized(srcCanvas, maxLongSide=1600, quality=0.85){
    const w = srcCanvas.width;
    const h = srcCanvas.height;
    if (!w || !h) return null;

    const longSide = Math.max(w,h);
    const scale = Math.min(1, maxLongSide / longSide);

    const tw = Math.max(1, Math.round(w * scale));
    const th = Math.max(1, Math.round(h * scale));

    let target = srcCanvas;
    if (scale < 0.999){
      const c = document.createElement("canvas");
      c.width = tw;
      c.height = th;
      const cctx = c.getContext("2d");
      cctx.imageSmoothingEnabled = true;
      cctx.imageSmoothingQuality = "high";
      cctx.drawImage(srcCanvas, 0,0,w,h, 0,0,tw,th);
      target = c;
    }

    const blob = await new Promise((resolve) => {
      target.toBlob((b)=>resolve(b), "image/jpeg", quality);
    });

    return blob;
  }

  async function fetchWithTimeout(url, options={}, timeoutMs=UPLOAD_TIMEOUT_MS){
    const controller = new AbortController();
    const id = setTimeout(()=>controller.abort(new Error("aborted")), timeoutMs);
    try{
      const res = await fetch(url, { ...options, signal: controller.signal });
      return res;
    } finally {
      clearTimeout(id);
    }
  }

  async function uploadBlob(blob){
    const formData = new FormData();
    formData.append("image", blob, `sleep_capture_${Date.now()}.jpg`);

    const base = (SLEEP_UPLOAD_SERVER && SLEEP_UPLOAD_SERVER.trim()) ? SLEEP_UPLOAD_SERVER.trim() : '';
    const url = base + "/upload";

    let res = await fetchWithTimeout(url, { method:"POST", body: formData }, UPLOAD_TIMEOUT_MS);

    if ((!res.ok && res.status >= 500) && UPLOAD_RETRY > 0){
      await new Promise(r=>setTimeout(r, 400));
      res = await fetchWithTimeout(url, { method:"POST", body: formData }, UPLOAD_TIMEOUT_MS);
    }
    return res;
  }

  async function uploadSnapshotCanvas(canvas){
    try{
      setSleepPhotoStatus('Uploading...');
      const blob = await canvasToJpegBlobResized(canvas, 1600, 0.85);
      if(!blob){
        setSleepPhotoStatus('Upload error');
        return;
      }

      const res = await uploadBlob(blob);

      if(!res.ok){
        const txt = await res.text().catch(()=> "");
        setSleepPhotoStatus(`Upload failed: ${res.status}${txt ? " / " + txt.slice(0,80) : ""}`);
        return;
      }

      const ct = res.headers.get("content-type") || "";
      if (ct.includes("application/json")){
        await res.json().catch(()=>({}));
      } else {
        await res.text().catch(()=> "");
      }

      setSleepPhotoStatus('Uploaded');
      setTimeout(()=>setSleepPhotoStatus(''), 2600);
    }catch(err){
      console.error("UPLOAD ERROR RAW:", err);
      setSleepPhotoStatus('Upload error: ' + humanErr(err));
      setTimeout(()=>setSleepPhotoStatus(''), 5200);
    }
  }

  /* =========================
     ✅ BOX DETECT assets
     ========================= */
  const LIMEN_LABELS = ["Mom","Hometown","Son Duk-Geum","GrandFather","Ocean"];
  const CLASS_TO_LIMEN = {
    person: "Mom",
    diningtable: "Hometown",
    bottle: "Ocean",
    cup: "Hometown",
    fork: "Son Duk-Geum",
    knife: "Son Duk-Geum",
    spoon: "Son Duk-Geum",
    chair: "GrandFather",
    tv: "Ocean",
    laptop: "Ocean",
    "cell phone": "Ocean"
  };
  function pickLimenLabelByClass(cocoClass, fallbackIndex){
    return CLASS_TO_LIMEN[cocoClass] || LIMEN_LABELS[fallbackIndex % LIMEN_LABELS.length];
  }
  function shuffleCopy(arr){
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  const LABEL_COLOR = {
    "Mom": [231,226,201],
    "Hometown": [231,226,201],
    "Son Duk-Geum": [231,226,201],
    "GrandFather": [231,226,201],
    "Ocean": [231,226,201]
  };

  const ASSET_FILES = {
    "Mom": "assets/mom.jpg",
    "Hometown": "assets/hometown.jpg",
    "Son Duk-Geum": "assets/son-duk-geum.jpg",
    "GrandFather": "assets/grandfather.jpg",
    "Ocean": "assets/ocean.jpg"
  };

  const assets = new Map();
  async function loadAssets(){
    assets.clear();
    const entries = Object.entries(ASSET_FILES);
    for (const [label, path] of entries){
      const img = new Image();
      img.crossOrigin = "anonymous";
      const rec = { el:img, ready:false, path };
      assets.set(label, rec);
      await new Promise((res) => {
        img.onload = () => { rec.ready = true; res(); };
        img.onerror = () => { rec.ready = false; res(); };
        img.src = path + "?v=" + Date.now();
      });
    }
    const ok = [...assets.values()].filter(a=>a.ready).length;
    log(`assets: ${ok}/${entries.length}`);
  }

  /* =========================
     ✅ coco-ssd model
     ========================= */
  let model=null;
  async function loadModel(){
    if(model) return model;
    statusEl.textContent = "Loading";
    log("model loading...");
    model = await cocoSsd.load({ base:"lite_mobilenet_v2" });
    log("model loaded");
    return model;
  }

  function iou(a,b){
    const ax1=a[0], ay1=a[1], ax2=a[0]+a[2], ay2=a[1]+a[3];
    const bx1=b[0], by1=b[1], bx2=b[0]+b[2], by2=b[1]+b[3];
    const ix1=Math.max(ax1,bx1), iy1=Math.max(ay1,by1);
    const ix2=Math.min(ax2,bx2), iy2=Math.min(ay2,by2);
    const iw=Math.max(0, ix2-ix1), ih=Math.max(0, iy2-iy1);
    const inter=iw*ih;
    const ua=a[2]*a[3] + b[2]*b[3] - inter;
    return ua>0 ? inter/ua : 0;
  }
  function center(b){ return {x:b[0]+b[2]/2, y:b[1]+b[3]/2}; }
  function makeLinks(points, k=2){
    const links=[];
    for(let i=0;i<points.length;i++){
      const ds=[];
      for(let j=0;j<points.length;j++){
        if(i===j) continue;
        const dx=points[i].x-points[j].x, dy=points[i].y-points[j].y;
        ds.push({j, d:dx*dx+dy*dy});
      }
      ds.sort((a,b)=>a.d-b.d);
      for(let t=0;t<Math.min(k, ds.length);t++){
        const j=ds[t].j;
        if(i<j) links.push([i,j,ds[t].d]);
      }
    }
    return links;
  }
  function fract(x){ return x - Math.floor(x); }
  function scaleBox(bbox, s){
    const [x,y,w,h]=bbox;
    const cx = x + w/2, cy = y + h/2;
    const nw = w * s, nh = h * s;
    return [cx - nw/2, cy - nh/2, nw, nh];
  }

  function drawFragmentIntoBox(assetRec, bbox, seed){
    if (!assetRec || !assetRec.ready) return;
    const [x,y,w,h] = bbox;
    if (w < 8 || h < 8) return;

    const t = performance.now() * 0.001;
    const r1 = fract(Math.sin(seed*12.9898 + t*1.3) * 43758.5453);
    const r2 = fract(Math.sin(seed*78.233  + t*0.9) * 12345.6789);
    const r3 = fract(Math.sin(seed*41.77   + t*1.7) * 98765.4321);

    vctx.save();
    vctx.beginPath(); vctx.rect(x,y,w,h); vctx.clip();

    const scale = 1.05 + r1 * 1.25;
    const ox = (r2 - 0.5) * w * 0.35;
    const oy = (r3 - 0.5) * h * 0.35;

    const el = assetRec.el;
    const sw = el.naturalWidth||0;
    const sh = el.naturalHeight||0;
    if (sw < 2 || sh < 2){ vctx.restore(); return; }

    const dw = w * scale, dh = h * scale;
    const dx = x + (w - dw)/2 + ox;
    const dy = y + (h - dh)/2 + oy;

    vctx.globalAlpha = 0.85;
    vctx.drawImage(el, dx, dy, dw, dh);

    vctx.globalAlpha = 0.32;
    const dw2 = w * (0.85 + r2*0.5);
    const dh2 = h * (0.85 + r3*0.5);
    const dx2 = x + (w - dw2)/2 - ox*0.25;
    const dy2 = y + (h - dh2)/2 - oy*0.25;
    vctx.drawImage(el, dx2, dy2, dw2, dh2);

    vctx.restore();
    vctx.globalAlpha = 1;
  }

  function drawLabelTag(label, cocoClass, x, y){
    const text = `${label} · ${cocoClass}`;
    vctx.font = `${Math.max(12, Math.round((view.clientWidth||innerWidth)/95))}px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;
    vctx.textBaseline = "top";
    const padX = 7, padY = 4;
    const tw = vctx.measureText(text).width;
    const th = Math.max(18, Math.round((view.clientWidth||innerWidth)/75));

    const ty = Math.max(0, y - th - 2);
    vctx.fillStyle = "rgba(0,0,0,0.60)";
    vctx.fillRect(x, ty, tw + padX*2, th);

    vctx.fillStyle = `rgba(231,226,201,0.95)`;
    vctx.fillText(text, x + padX, ty + padY);
  }

  function computeMinAreaFromFine(fine, vw, vh){
    const base = vw * vh;
    const minRatio = 0.0015;
    const maxRatio = 0.12;
    const r = minRatio + (1 - fine) * (maxRatio - minRatio);
    return base * r;
  }

  let objectTracks = [];
  let renderTracks = [];
  let nextId = 1;

  function ensureDistinctLabelsForTopN(objs, nowMs){
    const holdMs = (+holdSecEl.value) * 1000;

    for (const o of objs){
      if (!o.label || nowMs > o.labelUntil) o.label = null;
    }

    const used = new Set(objs.filter(o=>o.label).map(o=>o.label));
    for (let i=0;i<objs.length;i++){
      const o = objs[i];
      if (!o.label){
        let candidate = pickLimenLabelByClass(o.cls, i);
        if (used.has(candidate)){
          const pool = shuffleCopy(LIMEN_LABELS).filter(L=>!used.has(L));
          if (pool.length) candidate = pool[0];
        }
        o.label = candidate;
        o.labelUntil = nowMs + holdMs;
        used.add(candidate);
      }
    }
  }

  const DETECT_INTERVAL_MS = 240;
  let lastDetectAt = 0;
  let runningDetect = false;

  async function stepDetect(){
    if(!model) await loadModel();
    if(!camVideo || camVideo.readyState < 2) return;

    const coarse = +confEl.value;
    const fine = +fineEl.value;
    confVal.textContent = coarse.toFixed(2);
    fineVal.textContent = fine.toFixed(2);

    let wantN = +topNEl.value;
    wantN = clamp(wantN, 3, 8);
    topNVal.textContent = String(wantN);

    holdValEl.textContent = (+holdSecEl.value).toFixed(1) + "s";
    boxScaleValEl.textContent = (+boxScaleEl.value).toFixed(2);

    const vw = camVideo.videoWidth || 0;
    const vh = camVideo.videoHeight || 0;
    const minArea = computeMinAreaFromFine(fine, vw||1280, vh||720);

    let preds = await model.detect(camVideo);

    preds = preds
      .filter(p => (p.score >= coarse) && ((p.bbox[2]*p.bbox[3]) >= minArea))
      .sort((a,b) => b.score - a.score);

    const candidates = preds.slice(0, 12);
    const nowMs = performance.now();

    const used = new Set();
    for (const tr of objectTracks){
      let bestJ = -1, bestI = 0;
      for (let j=0;j<candidates.length;j++){
        if (used.has(j)) continue;
        const s = iou(tr.bbox, candidates[j].bbox);
        if (s > bestI){ bestI=s; bestJ=j; }
      }
      if (bestJ >= 0 && bestI > 0.18){
        const p = candidates[bestJ];
        used.add(bestJ);
        tr.bbox = lerpBox(tr.bbox, p.bbox, 0.55);
        tr.cls = p.class;
        tr.score = p.score;
        tr.lastSeen = nowMs;
      }
    }

    for (let j=0;j<candidates.length;j++){
      if (used.has(j)) continue;
      const p = candidates[j];
      objectTracks.push({
        id: nextId++,
        bbox: p.bbox.slice(),
        cls: p.class,
        score: p.score,
        label: null,
        labelUntil: 0,
        lastSeen: nowMs,
        seed: (nextId*971 + j*37) >>> 0
      });
    }

    objectTracks = objectTracks.filter(tr => (nowMs - tr.lastSeen) < 1200);
    objectTracks.sort((a,b)=>b.score-a.score);
    renderTracks = objectTracks.slice(0, wantN);
    ensureDistinctLabelsForTopN(renderTracks, nowMs);

    statusEl.textContent = usingUploadVideo ? "Upload" : "Camera";
  }

  function mapVideoBoxToScreen(bbox, T){
    const [x,y,w,h] = bbox;
    const sx = T.dx + (x / T.vw) * T.dw;
    const sy = T.dy + (y / T.vh) * T.dh;
    const sw = (w / T.vw) * T.dw;
    const sh = (h / T.vh) * T.dh;
    return [sx, sy, sw, sh];
  }

  function drawCameraAndDetect(){
    const W = view.clientWidth || innerWidth;
    const H = view.clientHeight || innerHeight;

    // always clear
    vctx.save();
    vctx.fillStyle = '#000';
    vctx.fillRect(0,0,W,H);
    vctx.restore();

    const T = getCameraDrawTransform();
    if(showCamera && T){
      vctx.save();
      vctx.globalAlpha = camFadeAlpha;
      vctx.drawImage(camVideo, T.dx, T.dy, T.dw, T.dh);
      vctx.restore();

      const boxScale = clamp(+boxScaleEl.value, 0.35, 1.20);

      if (linksEl.checked && renderTracks.length >= 2){
        const screenBoxes = renderTracks.map(tr => mapVideoBoxToScreen(tr.bbox, T));
        const scaledBoxes = screenBoxes.map(b => scaleBox(b, boxScale));
        const pts = scaledBoxes.map(b => center(b));
        const links = makeLinks(pts, 2);

        for (const [i,j,dd] of links){
          const a = pts[i], b = pts[j];
          const dist = Math.sqrt(dd);
          const norm = Math.min(1, dist / Math.max(W, H));
          const alpha = clamp((0.62*(1-norm) + 0.10), 0.05, 0.85);

          vctx.save();
          vctx.setLineDash([]);
          vctx.strokeStyle = `rgba(231,226,201,${alpha.toFixed(3)})`;
          vctx.lineWidth = Math.max(1.1, W/1150);
          vctx.beginPath();
          vctx.moveTo(a.x, a.y);
          vctx.lineTo(b.x, b.y);
          vctx.stroke();
          vctx.restore();
        }
      }

      vctx.lineWidth = Math.max(2, W/980);

      for (let idx=0; idx<renderTracks.length; idx++){
        const tr = renderTracks[idx];
        const label = tr.label || "—";

        const screenBox = mapVideoBoxToScreen(tr.bbox, T);
        const b = scaleBox(screenBox, boxScale);
        const [x,y,w,h] = b;

        if (fillFragEl.checked){
          const asset = assets.get(label);
          drawFragmentIntoBox(asset, b, (tr.seed + idx*77) >>> 0);
        }

        vctx.strokeStyle = `rgba(231,226,201,0.92)`;
        vctx.strokeRect(x,y,w,h);

        drawLabelTag(label, tr.cls, x, y);
      }

      countEl.textContent = "Boxes " + renderTracks.length;
    }
  }

  let lastT = performance.now();
  let emaFps = 0;

  async function tick(){
    if(!runningDetect) return;

    const now = performance.now();
    if ((now - lastDetectAt) > DETECT_INTERVAL_MS){
      lastDetectAt = now;
      try{ await stepDetect(); }
      catch(e){ log("DETECT ERROR: " + (e?.message || e)); }
    }

    const dt = (now - lastT) / 1000;
    lastT = now;
    const inst = dt>0 ? (1/dt) : 0;
    emaFps = emaFps ? (emaFps*0.9 + inst*0.1) : inst;
    fpsEl.textContent = "FPS " + emaFps.toFixed(1);

    requestAnimationFrame(tick);
  }

  function renderLoop(){
    drawCameraAndDetect();
    requestAnimationFrame(renderLoop);
  }
  requestAnimationFrame(renderLoop);

  /* =========================
     CAPTURE → 업로드
     ========================= */
  let capturing=false;
  async function captureCurrentView(){
    if(capturing) return;
    capturing = true;
    try{
      setSleepPhotoStatus('Capturing...');
      const w = view.width;
      const h = view.height;

      freezeLayer.width = w;
      freezeLayer.height = h;

      const ctx = freezeLayer.getContext('2d');
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,w,h);
      ctx.drawImage(view, 0,0, w, h);

      await uploadSnapshotCanvas(freezeLayer);
    }catch(e){
      setSleepPhotoStatus('Capture error');
      setTimeout(()=>setSleepPhotoStatus(''), 5000);
    }finally{
      freezeLayer.style.display = 'none';
      capturing = false;
    }
  }

  captureBtn.addEventListener('click', async (e)=>{
    e.preventDefault();
    await ensureResumed();
    playClick();
    captureCurrentView();
  }, {passive:false});

  /* =========================
     UI 동작
     ========================= */
  flipBtn.addEventListener('click', async ()=>{
    try{
      facingMode = (facingMode === "environment") ? "user" : "environment";
      if(!usingUploadVideo){
        await startCameraFresh();
        fadeInCamera(500);
      }
      log("flip: " + facingMode);
      playClick();
    }catch(e){
      log("flip error");
    }
  }, {passive:true});

  restartBtn.addEventListener('click', ()=>{
    objectTracks = [];
    renderTracks = [];
    lastDetectAt = 0;
    log("restart");
    playClick();
  }, {passive:true});

  useCamBtn.addEventListener('click', async ()=>{
    try{
      await startCameraFresh();
      fadeInCamera(500);
      objectTracks = [];
      renderTracks = [];
      log("source: camera");
      playClick();
    }catch(e){
      log("camera error");
    }
  }, {passive:true});

  videoFileEl.addEventListener('change', async ()=>{
    const file = videoFileEl.files?.[0];
    if(!file) return;
    try{
      await useUploadedVideo(file);
      fadeInCamera(500);
      objectTracks = [];
      renderTracks = [];
      log("uploaded: " + file.name);
      playClick();
    }catch(e){
      log("upload error");
    }
  }, {passive:true});

  /* =========================
     ✅ New flow:
     1) Tap anywhere → request camera permission + warm up model/assets
     2) Fade to Title scene
     3) Tap to enter → start camera + show UI
     ========================= */
  let permDone = false;
  let warmed = false;

  async function warmUp(){
    if (warmed) return;
    warmed = true;
    try{
      statusEl.textContent = "Loading";
      await loadModel();
      await loadAssets();
      statusEl.textContent = "Idle";
      log("ready");
    }catch(e){
      log("load error");
    }
  }

  async function requestCameraPermission(){
    try{
      const s = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:{ideal:facingMode} },
        audio:false
      });
      s.getTracks().forEach(t=>t.stop());
      permDone = true;
      return true;
    }catch(e){
      permDone = false;
      return false;
    }
  }

  async function onPermTap(e){
    if(e && e.preventDefault) e.preventDefault();
    await ensureResumed();
    playClick();

    // ask permission
    const ok = await requestCameraPermission();
    await warmUp();

    // even if user denies, we still proceed to title (so experience continues)
    fadeToScene(scenePerm, sceneTitle);
  }

  async function enterProgram(e){
    if(e && e.preventDefault) e.preventDefault();
    await ensureResumed();
    playClick();

    // start camera now (if denied, show log and still hide overlay)
    try{
      await startCameraFresh();
      fadeInCamera(900);
    }catch(err){
      log("camera start failed");
    }

    fadeOutOverlay();
    controls.classList.add('show');
    captureBtn.classList.add('show');
    logEl.classList.add('show');

    runningDetect = true;
    lastT = performance.now();
    lastDetectAt = 0;
    tick();
  }

  // Scene 1 tap
  ['click','touchstart','pointerdown'].forEach(type=>{
    scenePerm.addEventListener(type, onPermTap, {passive:false});
  });

  // Scene 2 tap
  ['click','touchstart','pointerdown'].forEach(type=>{
    sceneTitle.addEventListener(type, enterProgram, {passive:false});
  });

})();
</script>
</body>
</html>
