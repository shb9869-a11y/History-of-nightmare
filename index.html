<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>BOX DETECT – Object Boxes + Relational Aesthetics</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="BOX DETECT">
<meta name="theme-color" content="#000000">

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>

<style>
  html,body{margin:0;height:100%;background:#000;color:#ddd;font-family:system-ui,-apple-system,sans-serif;overflow:hidden;}
  #wrap{position:fixed;inset:0; pointer-events:none;}
  video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover; pointer-events:none;}
  #srcVideo{filter: grayscale(1) contrast(1.15) brightness(1.05);}

  #ui{
    position:fixed; top:12px; left:12px; right:12px;
    display:flex; flex-wrap:wrap; gap:10px; align-items:center;
    z-index:10;
    background:rgba(0,0,0,.45);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    padding:10px 12px;
    backdrop-filter: blur(8px);
    transition:.2s;
    pointer-events:auto;
  }
  #ui.hidden{opacity:0; pointer-events:none; transform:translateY(-10px);}
  .pill{
    display:flex; gap:8px; align-items:center;
    background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.10);
    border-radius:999px;
    padding:8px 10px;
  }
  button{
    appearance:none;border:1px solid rgba(255,255,255,.18);
    background:rgba(255,255,255,.08); color:#fff;
    padding:10px 14px; border-radius:14px; font-weight:800;
    touch-action: manipulation;
    pointer-events:auto;
  }
  button:active{transform:translateY(1px);}
  input, label{pointer-events:auto;}
  input[type=range]{width:120px}

  #toggleUI{
    position:fixed; top:12px; right:12px;
    z-index:11;
    border-radius:999px;
    background:rgba(0,0,0,.45);
    border:1px solid rgba(255,255,255,.12);
    padding:10px 12px;
    backdrop-filter: blur(8px);
    pointer-events:auto;
  }

  #gate{
    position:fixed; inset:0;
    display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.78);
    z-index:20;
    padding:20px;
    pointer-events:auto;
  }
  #gate .box{
    width:min(860px,94vw);
    background:rgba(0,0,0,.55);
    border:1px solid rgba(255,255,255,.12);
    border-radius:18px;
    padding:16px;
    pointer-events:auto;
  }
  #gate h1{margin:0 0 6px; font-size:18px;}
  #gate p{margin:6px 0; font-size:14px; color:#ccc;}
  #gate .row{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;}
  #start{padding:14px 18px;border-radius:16px;font-size:16px;}

  #log{
    position:fixed; left:12px; bottom:12px;
    z-index:10;
    font-size:12px;
    background:rgba(0,0,0,.45);
    border:1px solid rgba(255,255,255,.12);
    border-radius:12px;
    padding:8px 10px;
    backdrop-filter: blur(8px);
    max-width:min(86vw,820px);
    white-space:pre-wrap;
    pointer-events:none;
  }
</style>
</head>

<body>
<div id="wrap">
  <video id="srcVideo" autoplay playsinline muted></video>
  <canvas id="out"></canvas>
</div>

<button id="toggleUI">☰ 메뉴</button>

<div id="ui">
  <!-- ✅ COARSE(덩어리 감도): 기존 conf를 그대로 사용 -->
  <div class="pill">
    <b>COARSE</b>
    <input id="conf" type="range" min="0.01" max="0.95" step="0.01" value="0.12">
    <span id="confVal">0.12</span>
  </div>

  <!-- ✅ FINE(미세 감도): 최소 박스 면적 필터 -->
  <div class="pill">
    <b>FINE</b>
    <input id="fine" type="range" min="0.00" max="1.00" step="0.01" value="0.40">
    <span id="fineVal">0.40</span>
  </div>

  <div class="pill">
    <b>N(물체)</b>
    <input id="topN" type="range" min="3" max="8" step="1" value="4">
    <span id="topNVal">4</span>
  </div>

  <div class="pill">
    <b>HOLD</b>
    <input id="holdSec" type="range" min="1" max="10" step="0.5" value="3.0">
    <span id="holdVal">3.0s</span>
  </div>

  <!-- ✅ BOX 범위 확장: 0.35~1.20 -->
  <div class="pill">
    <b>BOX</b>
    <input id="boxScale" type="range" min="0.35" max="1.20" step="0.01" value="0.88">
    <span id="boxScaleVal">0.88</span>
  </div>

  <div class="pill">
    <label style="display:flex;align-items:center;gap:6px;">
      <input id="links" type="checkbox" checked> 선 연결
    </label>
    <label style="display:flex;align-items:center;gap:6px;">
      <input id="fillFrag" type="checkbox" checked> 박스 파편 채우기
    </label>
  </div>

  <div class="pill">
    <button id="fullscreen">전체화면</button>
    <button id="flip">전/후면</button>
    <button id="restart">재시작</button>
  </div>

  <div class="pill">
    <b>소스</b>
    <button id="useCam">카메라</button>
    <label style="display:flex;align-items:center;gap:6px;">
      <input id="videoFile" type="file" accept="video/*" style="max-width:220px;">
      <span style="opacity:.9">업로드 영상</span>
    </label>
  </div>

  <div class="pill">
    <b>녹화</b>
    <button id="recStart">시작</button>
    <button id="recStop">정지</button>
    <label style="display:flex;align-items:center;gap:6px;">
      <span>자동정지</span>
      <input id="recSec" type="range" min="3" max="120" step="1" value="12">
      <span id="recSecVal">12s</span>
    </label>
    <span style="opacity:.85;font-size:12px">※ mp4 우선 저장(미지원 시 webm)</span>
  </div>

  <div class="pill">
    <span id="status">대기</span>
    <span id="fps">FPS -</span>
    <span id="count">Boxes 0</span>
  </div>
</div>

<div id="log">ready</div>

<div id="gate">
  <div class="box">
    <h1>OBJECT BOXES + RELATION AESTHETICS</h1>
    <p>
      실제 물체를 “있는 크기 그대로” 잡고, 최소 3개 이상 포착 + 라벨 3종 이상(중복 금지) 유지.<br>
      COARSE(덩어리/점수) + FINE(미세/최소면적)로 “탐지 성격”을 조절하고, BOX로 “표현 크기”를 조절.
    </p>
    <div class="row">
      <button id="start">시작</button>
      <button id="preloadAssets">assets 다시 로드</button>
    </div>
  </div>
</div>

<script>
(() => {
  const srcV = document.getElementById("srcVideo");
  const out = document.getElementById("out");
  const ctx = out.getContext("2d");

  const gate = document.getElementById("gate");
  const logEl = document.getElementById("log");

  const confEl = document.getElementById("conf");
  const confVal = document.getElementById("confVal");

  const fineEl = document.getElementById("fine");
  const fineVal = document.getElementById("fineVal");

  const topNEl = document.getElementById("topN");
  const topNVal = document.getElementById("topNVal");
  const holdSecEl = document.getElementById("holdSec");
  const holdValEl = document.getElementById("holdVal");
  const boxScaleEl = document.getElementById("boxScale");
  const boxScaleValEl = document.getElementById("boxScaleVal");

  const linksEl = document.getElementById("links");
  const fillFragEl = document.getElementById("fillFrag");

  const toggleUIBtn = document.getElementById("toggleUI");
  const ui = document.getElementById("ui");

  const startBtn = document.getElementById("start");
  const preloadAssetsBtn = document.getElementById("preloadAssets");
  const fullscreenBtn = document.getElementById("fullscreen");
  const flipBtn = document.getElementById("flip");
  const restartBtn = document.getElementById("restart");

  const useCamBtn = document.getElementById("useCam");
  const videoFileEl = document.getElementById("videoFile");

  const recStartBtn = document.getElementById("recStart");
  const recStopBtn = document.getElementById("recStop");
  const recSecEl = document.getElementById("recSec");
  const recSecVal = document.getElementById("recSecVal");

  const statusEl = document.getElementById("status");
  const fpsEl = document.getElementById("fps");
  const countEl = document.getElementById("count");

  function log(msg){ logEl.textContent = String(msg); }

  const LIMEN_LABELS = ["Mom", "Hometown", "Son Duk-Geum", "GrandFather", "Ocean"];
  const CLASS_TO_LIMEN = {
    person: "Mom",
    diningtable: "Hometown",
    bottle: "Ocean",
    cup: "Hometown",
    fork: "Son Duk-Geum",
    knife: "Son Duk-Geum",
    spoon: "Son Duk-Geum",
    chair: "GrandFather",
    tv: "Ocean",
    laptop: "Ocean",
    "cell phone": "Ocean"
  };
  function pickLimenLabelByClass(cocoClass, fallbackIndex){
    return CLASS_TO_LIMEN[cocoClass] || LIMEN_LABELS[fallbackIndex % LIMEN_LABELS.length];
  }
  function shuffleCopy(arr){
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  const LABEL_COLOR = {
    "Mom": [255,140,140],
    "Hometown": [140,255,180],
    "Son Duk-Geum": [255,255,140],
    "GrandFather": [190,190,255],
    "Ocean": [140,190,255]
  };

  const ASSET_FILES = {
    "Mom": "assets/mom.jpg",
    "Hometown": "assets/hometown.jpg",
    "Son Duk-Geum": "assets/son-duk-geum.jpg",
    "GrandFather": "assets/grandfather.jpg",
    "Ocean": "assets/ocean.jpg"
  };

  const assets = new Map();
  function guessTypeByPath(p){
    const low = p.toLowerCase();
    if (low.endsWith(".mp4") || low.endsWith(".webm") || low.endsWith(".mov")) return "vid";
    return "img";
  }

  async function loadAssets(){
    assets.clear();
    const entries = Object.entries(ASSET_FILES);
    for (const [label, path] of entries){
      const type = guessTypeByPath(path);
      if (type === "img"){
        const img = new Image();
        img.crossOrigin = "anonymous";
        const rec = { type:"img", el:img, ready:false, path };
        assets.set(label, rec);
        await new Promise((res) => {
          img.onload = () => { rec.ready = true; res(); };
          img.onerror = () => { rec.ready = false; res(); };
          img.src = path + "?v=" + Date.now();
        });
      } else {
        const vid = document.createElement("video");
        vid.crossOrigin = "anonymous";
        vid.muted = true; vid.loop = true; vid.playsInline = true;
        const rec = { type:"vid", el:vid, ready:false, path };
        assets.set(label, rec);
        await new Promise((res) => {
          vid.onloadeddata = async () => { try { await vid.play(); } catch(e) {} rec.ready=true; res(); };
          vid.onerror = () => { rec.ready = false; res(); };
          vid.src = path + "?v=" + Date.now();
        });
      }
    }
    const ok = [...assets.values()].filter(a=>a.ready).length;
    log(`assets loaded: ${ok}/${entries.length} (없어도 동작함)`);
  }

  let stream = null;
  let facingMode = "environment";
  let usingUploadVideo = false;

  async function startCamera(){
    usingUploadVideo = false;
    if (stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    statusEl.textContent = "카메라 요청";
    log("camera requesting...");
    stream = await navigator.mediaDevices.getUserMedia({
      audio:false,
      video:{ facingMode:{ ideal:facingMode }, width:{ideal:1280}, height:{ideal:720} }
    });
    srcV.srcObject = stream;
    await srcV.play();
    resize();
    log("camera started: " + facingMode);
  }

  async function useUploadedVideo(file){
    usingUploadVideo = true;
    if (stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    const url = URL.createObjectURL(file);
    srcV.srcObject = null;
    srcV.src = url;
    srcV.loop = true;
    srcV.muted = true;
    await srcV.play();
    resize();
    log("uploaded video: " + file.name);
  }

  function resize(){
    const w = srcV.videoWidth || innerWidth;
    const h = srcV.videoHeight || innerHeight;
    if (out.width !== w) out.width = w;
    if (out.height !== h) out.height = h;
  }
  window.addEventListener("resize", resize);

  let model = null;
  async function loadModel(){
    if (model) return model;
    statusEl.textContent = "모델 로딩";
    log("model loading...");
    model = await cocoSsd.load({ base:"lite_mobilenet_v2" });
    log("model loaded");
    return model;
  }

  // ====== utils ======
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function iou(a,b){
    const ax1=a[0], ay1=a[1], ax2=a[0]+a[2], ay2=a[1]+a[3];
    const bx1=b[0], by1=b[1], bx2=b[0]+b[2], by2=b[1]+b[3];
    const ix1=Math.max(ax1,bx1), iy1=Math.max(ay1,by1);
    const ix2=Math.min(ax2,bx2), iy2=Math.min(ay2,by2);
    const iw=Math.max(0, ix2-ix1), ih=Math.max(0, iy2-iy1);
    const inter=iw*ih;
    const ua=a[2]*a[3] + b[2]*b[3] - inter;
    return ua>0 ? inter/ua : 0;
  }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function lerpBox(cur, target, t){
    return [lerp(cur[0], target[0], t), lerp(cur[1], target[1], t), lerp(cur[2], target[2], t), lerp(cur[3], target[3], t)];
  }
  function center(b){ return {x:b[0]+b[2]/2, y:b[1]+b[3]/2}; }
  function makeLinks(points, k=2){
    const links=[];
    for(let i=0;i<points.length;i++){
      const ds=[];
      for(let j=0;j<points.length;j++){
        if(i===j) continue;
        const dx=points[i].x-points[j].x, dy=points[i].y-points[j].y;
        ds.push({j, d:dx*dx+dy*dy});
      }
      ds.sort((a,b)=>a.d-b.d);
      for(let t=0;t<Math.min(k, ds.length);t++){
        const j=ds[t].j;
        if(i<j) links.push([i,j,ds[t].d]);
      }
    }
    return links;
  }
  function fract(x){ return x - Math.floor(x); }

  // ✅ “그려지는 박스만” 축소/확대
  function scaleBox(bbox, s){
    const [x,y,w,h]=bbox;
    const cx = x + w/2, cy = y + h/2;
    const nw = w * s, nh = h * s;
    return [cx - nw/2, cy - nh/2, nw, nh];
  }

  // ====== 관계의 미학 ======
  function getLinkStyle(aLabel, bLabel, t){
    const pair = [aLabel, bLabel].sort().join("|");
    let widthMul = 1.0, alphaMul = 1.0, jitter = 0.0, dash = null, pulse = 0.0, glow = 0.0;

    if (aLabel==="Mom" || bLabel==="Mom"){ widthMul=1.35; alphaMul=1.20; pulse=0.18; }
    if (aLabel==="Ocean" || bLabel==="Ocean"){ alphaMul*=0.78; jitter=1.2; dash=[6,10]; }
    if (aLabel==="GrandFather" || bLabel==="GrandFather"){ pulse=Math.max(pulse,0.38); }
    if (aLabel==="Hometown" || bLabel==="Hometown"){ dash = dash || [10,6]; }
    if (aLabel==="Son Duk-Geum" || bLabel==="Son Duk-Geum"){ glow=0.7; }

    if (pair === "Hometown|Mom") alphaMul *= 1.10;
    if (pair === "GrandFather|Ocean") jitter *= 1.35;

    const pulseFactor = 1 + pulse * Math.sin(t*1.6);
    return { widthMul: widthMul*pulseFactor, alphaMul, jitter, dash, glow };
  }

  // ====== 파편 채우기 ======
  function drawFragmentIntoBox(assetRec, bbox, seed){
    if (!assetRec || !assetRec.ready) return;
    const [x,y,w,h] = bbox;
    if (w < 8 || h < 8) return;

    const t = performance.now() * 0.001;
    const r1 = fract(Math.sin(seed*12.9898 + t*1.3) * 43758.5453);
    const r2 = fract(Math.sin(seed*78.233  + t*0.9) * 12345.6789);
    const r3 = fract(Math.sin(seed*41.77   + t*1.7) * 98765.4321);

    ctx.save();
    ctx.beginPath(); ctx.rect(x,y,w,h); ctx.clip();

    const scale = 1.05 + r1 * 1.25;
    const ox = (r2 - 0.5) * w * 0.35;
    const oy = (r3 - 0.5) * h * 0.35;

    const el = assetRec.el;
    let sw=0, sh=0;
    if (assetRec.type === "img"){ sw = el.naturalWidth||0; sh = el.naturalHeight||0; }
    else { sw = el.videoWidth||0; sh = el.videoHeight||0; }
    if (sw < 2 || sh < 2){ ctx.restore(); return; }

    const dw = w * scale, dh = h * scale;
    const dx = x + (w - dw)/2 + ox;
    const dy = y + (h - dh)/2 + oy;

    ctx.globalAlpha = 0.85;
    ctx.drawImage(el, dx, dy, dw, dh);

    ctx.globalAlpha = 0.32;
    const dw2 = w * (0.85 + r2*0.5);
    const dh2 = h * (0.85 + r3*0.5);
    const dx2 = x + (w - dw2)/2 - ox*0.25;
    const dy2 = y + (h - dh2)/2 - oy*0.25;
    ctx.drawImage(el, dx2, dy2, dw2, dh2);

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawLabelTag(label, cocoClass, x, y){
    const col = LABEL_COLOR[label] || [255,255,255];
    const text = `${label} · ${cocoClass}`;
    ctx.font = `${Math.max(12, Math.round(out.width/95))}px system-ui,-apple-system,sans-serif`;
    ctx.textBaseline = "top";
    const padX = 7, padY = 4;
    const tw = ctx.measureText(text).width;
    const th = Math.max(18, Math.round(out.width/75));

    const ty = Math.max(0, y - th - 2);
    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.fillRect(x, ty, tw + padX*2, th);

    ctx.fillStyle = `rgba(${col[0]},${col[1]},${col[2]},0.98)`;
    ctx.fillText(text, x + padX, ty + padY);
  }

  // ====== object tracks ======
  let objectTracks = [];
  let renderTracks = [];
  let nextId = 1;

  function ensureDistinctLabelsForTopN(objs, nowMs){
    const holdMs = (+holdSecEl.value) * 1000;

    for (const o of objs){
      if (!o.label || nowMs > o.labelUntil) o.label = null;
    }

    const used = new Set(objs.filter(o=>o.label).map(o=>o.label));
    for (let i=0;i<objs.length;i++){
      const o = objs[i];
      if (!o.label){
        let candidate = pickLimenLabelByClass(o.cls, i);
        if (used.has(candidate)){
          const pool = shuffleCopy(LIMEN_LABELS).filter(L=>!used.has(L));
          if (pool.length) candidate = pool[0];
        }
        o.label = candidate;
        o.labelUntil = nowMs + holdMs;
        used.add(candidate);
      }
    }

    if (objs.length >= 3){
      let uniq = new Set(objs.map(o=>o.label));
      if (uniq.size < 3){
        const pool = shuffleCopy(LIMEN_LABELS).filter(L=>!uniq.has(L));
        const counts = {};
        objs.forEach(o=>{ counts[o.label]=(counts[o.label]||0)+1; });
        const dup = objs.slice().sort((a,b)=>(counts[b.label]||0)-(counts[a.label]||0));
        for (const o of dup){
          uniq = new Set(objs.map(x=>x.label));
          if (uniq.size >= 3) break;
          const next = pool.shift();
          if (!next) break;
          o.label = next;
          o.labelUntil = nowMs + holdMs;
        }
      }
    }
  }

  // ====== detection loop ======
  const DETECT_INTERVAL_MS = 240;
  let lastDetectAt = 0;

  // ✅ FINE -> 최소 박스 면적(화면 대비 비율)로 변환
  // fine=1.0 : 아주 작은 것까지 허용(최소면적 매우 작음)
  // fine=0.0 : 작은 것은 걸러지고 큰 것 위주(최소면적 큼)
  function computeMinAreaFromFine(fine){
    const W = out.width || innerWidth;
    const H = out.height || innerHeight;
    const base = W * H;
    const minRatio = 0.0015; // fine=1일 때 최소 면적 비율
    const maxRatio = 0.12;   // fine=0일 때 최소 면적 비율
    const r = minRatio + (1 - fine) * (maxRatio - minRatio);
    return base * r;
  }

  async function stepDetect(){
    const coarse = +confEl.value;     // ✅ COARSE(덩어리)
    const fine = +fineEl.value;       // ✅ FINE(미세)
    confVal.textContent = coarse.toFixed(2);
    fineVal.textContent = fine.toFixed(2);

    let wantN = +topNEl.value;
    wantN = clamp(wantN, 3, 8);
    topNVal.textContent = String(wantN);

    holdValEl.textContent = (+holdSecEl.value).toFixed(1) + "s";
    boxScaleValEl.textContent = (+boxScaleEl.value).toFixed(2);

    const minArea = computeMinAreaFromFine(fine);

    let preds = await model.detect(srcV);

    // ✅ COARSE + FINE 동시 적용:
    // - COARSE: score 기준
    // - FINE: bbox 면적 기준
    preds = preds
      .filter(p => (p.score >= coarse) && ((p.bbox[2]*p.bbox[3]) >= minArea))
      .sort((a,b) => b.score - a.score);

    const candidates = preds.slice(0, 12);
    const nowMs = performance.now();

    const used = new Set();
    for (const tr of objectTracks){
      let bestJ = -1, bestI = 0;
      for (let j=0;j<candidates.length;j++){
        if (used.has(j)) continue;
        const s = iou(tr.bbox, candidates[j].bbox);
        if (s > bestI){ bestI=s; bestJ=j; }
      }
      if (bestJ >= 0 && bestI > 0.18){
        const p = candidates[bestJ];
        used.add(bestJ);
        tr.bbox = lerpBox(tr.bbox, p.bbox, 0.55);
        tr.cls = p.class;
        tr.score = p.score;
        tr.lastSeen = nowMs;
      }
    }

    for (let j=0;j<candidates.length;j++){
      if (used.has(j)) continue;
      const p = candidates[j];
      objectTracks.push({
        id: nextId++,
        bbox: p.bbox.slice(),
        cls: p.class,
        score: p.score,
        label: null,
        labelUntil: 0,
        lastSeen: nowMs,
        seed: (nextId*971 + j*37) >>> 0
      });
    }

    objectTracks = objectTracks.filter(tr => (nowMs - tr.lastSeen) < 1200);
    objectTracks.sort((a,b)=>b.score-a.score);
    let active = objectTracks.slice(0, wantN);

    if (active.length < 3){
      const fallback = objectTracks.slice().sort((a,b)=>b.lastSeen-a.lastSeen).slice(0, Math.min(3, objectTracks.length));
      if (fallback.length >= 3) active = fallback;
    }

    renderTracks = active;
    ensureDistinctLabelsForTopN(renderTracks, nowMs);

    if (renderTracks.length < 3) {
      statusEl.textContent = (usingUploadVideo ? "업로드" : "카메라") + " · 물체 3개 필요";
    } else {
      statusEl.textContent = usingUploadVideo ? "업로드 영상" : "카메라";
    }
  }

  function render(){
    ctx.clearRect(0,0,out.width,out.height);

    // ✅ BOX 범위 확장 반영
    const boxScale = clamp(+boxScaleEl.value, 0.35, 1.20);

    if (linksEl.checked && renderTracks.length >= 2){
      const scaledBoxes = renderTracks.map(t => scaleBox(t.bbox, boxScale));
      const pts = scaledBoxes.map(b => center(b));
      const links = makeLinks(pts, 2);
      const t = performance.now()*0.001;

      for (const [i,j,dd] of links){
        const A = renderTracks[i], B = renderTracks[j];
        const a = pts[i], b = pts[j];

        const dist = Math.sqrt(dd);
        const norm = Math.min(1, dist / Math.max(out.width, out.height));

        const style = getLinkStyle(A.label, B.label, t);
        const baseAlpha = (0.70*(1-norm) + 0.10) * style.alphaMul;
        const alpha = clamp(baseAlpha, 0.05, 0.95);

        ctx.save();
        if (style.dash) ctx.setLineDash(style.dash);
        else ctx.setLineDash([]);

        const jx = style.jitter ? (Math.sin((i+1)*13.1 + t*4.0) * style.jitter) : 0;
        const jy = style.jitter ? (Math.cos((j+1)*9.7  + t*3.4) * style.jitter) : 0;

        const baseW = Math.max(1.2, out.width/1100) * style.widthMul;

        ctx.strokeStyle = `rgba(255,255,255,${alpha.toFixed(3)})`;
        ctx.lineWidth = baseW;

        ctx.beginPath();
        ctx.moveTo(a.x + jx, a.y + jy);
        ctx.lineTo(b.x - jx, b.y - jy);
        ctx.stroke();

        if (style.glow > 0){
          const glowA = clamp(alpha + (0.12 + 0.18*Math.sin(t*6.0 + i))*style.glow, 0.08, 0.95);
          ctx.setLineDash([]);
          ctx.strokeStyle = `rgba(255,255,255,${glowA.toFixed(3)})`;
          ctx.lineWidth = baseW * 1.6;
          ctx.beginPath();
          ctx.moveTo(a.x - jx*0.6, a.y - jy*0.6);
          ctx.lineTo(b.x + jx*0.6, b.y + jy*0.6);
          ctx.stroke();
        }

        ctx.restore();
      }
    }

    ctx.lineWidth = Math.max(2, out.width/900);

    for (let idx=0; idx<renderTracks.length; idx++){
      const tr = renderTracks[idx];
      const label = tr.label || "—";
      const col = LABEL_COLOR[label] || [255,255,255];

      const b = scaleBox(tr.bbox, boxScale);
      const [x,y,w,h] = b;

      if (fillFragEl.checked){
        const asset = assets.get(label);
        drawFragmentIntoBox(asset, b, (tr.seed + idx*77) >>> 0);
      }

      ctx.strokeStyle = `rgba(${col[0]},${col[1]},${col[2]},0.98)`;
      ctx.strokeRect(x,y,w,h);

      drawLabelTag(label, tr.cls, x, y);

      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.beginPath();
      ctx.arc(x+w/2, y+h/2, Math.max(2, out.width/750), 0, Math.PI*2);
      ctx.fill();
    }

    countEl.textContent = "Boxes " + renderTracks.length;
  }

  // ====== main loop ======
  let running = false;
  let lastT = performance.now();
  let emaFps = 0;

  async function tick(){
    if (!running) return;
    try{
      if (!model) await loadModel();
      if (srcV.readyState < 2){ requestAnimationFrame(tick); return; }
      resize();

      const now = performance.now();
      if ((now - lastDetectAt) > DETECT_INTERVAL_MS){
        lastDetectAt = now;
        await stepDetect();
      }

      render();

      const dt = (now - lastT) / 1000;
      lastT = now;
      const inst = dt>0 ? (1/dt) : 0;
      emaFps = emaFps ? (emaFps*0.9 + inst*0.1) : inst;
      fpsEl.textContent = "FPS " + emaFps.toFixed(1);

      requestAnimationFrame(tick);
    }catch(e){
      running = false;
      statusEl.textContent = "오류";
      log("ERROR: " + (e?.message || e));
      console.error(e);
    }
  }

  // ====== UI ======
  toggleUIBtn.onclick = ()=>{
    ui.classList.toggle("hidden");
    toggleUIBtn.textContent = ui.classList.contains("hidden") ? "☰ 메뉴" : "✕ 닫기";
  };

  fullscreenBtn.onclick = async ()=>{
    try{
      const el = document.documentElement;
      if (!document.fullscreenElement) await el.requestFullscreen?.();
      else await document.exitFullscreen?.();
    }catch(e){ log("fullscreen error: " + (e?.message || e)); }
  };

  useCamBtn.onclick = async ()=>{
    try{ await startCamera(); log("source: camera"); }catch(e){ log("camera error: " + (e?.message || e)); }
  };

  videoFileEl.onchange = async ()=>{
    const file = videoFileEl.files?.[0];
    if (!file) return;
    try{ await useUploadedVideo(file); }catch(e){ log("upload video error: " + (e?.message || e)); }
  };

  flipBtn.onclick = async ()=>{
    try{
      facingMode = (facingMode === "environment") ? "user" : "environment";
      if (!usingUploadVideo) await startCamera();
      log("flip: " + facingMode);
    }catch(e){ log("flip error: " + (e?.message || e)); }
  };

  restartBtn.onclick = ()=>{
    if (!model) { log("not started"); return; }
    running = false;
    objectTracks = [];
    renderTracks = [];
    ctx.clearRect(0,0,out.width,out.height);
    running = true;
    lastT = performance.now();
    lastDetectAt = 0;
    tick();
    log("restart");
  };

  boxScaleEl.oninput = ()=> boxScaleValEl.textContent = (+boxScaleEl.value).toFixed(2);
  fineEl.oninput = ()=> fineVal.textContent = (+fineEl.value).toFixed(2);
  confEl.oninput = ()=> confVal.textContent = (+confEl.value).toFixed(2);
  recSecEl.oninput = ()=> recSecVal.textContent = recSecEl.value + "s";

  preloadAssetsBtn.onclick = async ()=>{ await loadAssets(); };

  // ====== recording: mp4 우선, 미지원이면 webm ======
  let recorder=null, recChunks=[], recTimer=null;
  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
  }

  function pickRecorderMime(){
    const cand = [
      "video/mp4;codecs=avc1.42E01E,mp4a.40.2",
      "video/mp4;codecs=avc1.42E01E",
      "video/mp4",
      "video/webm;codecs=vp9",
      "video/webm;codecs=vp8",
      "video/webm"
    ];
    for (const m of cand){
      if (window.MediaRecorder && MediaRecorder.isTypeSupported(m)) return m;
    }
    return "";
  }

  recStartBtn.onclick = ()=>{
    if (!window.MediaRecorder){ log("MediaRecorder not supported"); return; }
    try{
      const s = out.captureStream(30);
      recChunks = [];

      const mime = pickRecorderMime();
      if (!mime){ log("no supported recorder mime"); return; }

      const isMp4 = mime.startsWith("video/mp4");
      recorder = new MediaRecorder(s, { mimeType: mime, videoBitsPerSecond: 4_000_000 });

      recorder.ondataavailable = (e)=>{ if (e.data && e.data.size) recChunks.push(e.data); };
      recorder.onstop = ()=>{
        const blob = new Blob(recChunks, { type: recorder.mimeType || (isMp4 ? "video/mp4" : "video/webm") });
        const ts = new Date().toISOString().replaceAll(":","-").replaceAll(".","-");
        const ext = isMp4 ? "mp4" : "webm";
        downloadBlob(blob, `BOX-DETECT-${ts}.${ext}`);
        log("record saved (" + ext + ")");
      };

      recorder.start(250);

      const sec = +recSecEl.value;
      clearTimeout(recTimer);
      recTimer = setTimeout(()=>{ try{ recorder?.stop(); }catch(e){} }, sec*1000);

      log("recording... mime=" + mime);
    }catch(e){
      log("record error: " + (e?.message || e));
    }
  };

  recStopBtn.onclick = ()=>{
    try{
      clearTimeout(recTimer);
      if (recorder && recorder.state !== "inactive") recorder.stop();
    }catch(e){ log("stop error: " + (e?.message || e)); }
  };

  async function doStart(){
    try{
      gate.style.display = "none";
      statusEl.textContent = "준비";
      await loadModel();
      await loadAssets();
      await startCamera();
      running = true;
      lastT = performance.now();
      lastDetectAt = 0;
      tick();
      log("running");
    }catch(e){
      statusEl.textContent = "오류";
      log("START ERROR: " + (e?.message || e));
      gate.style.display = "";
      console.error(e);
    }
  }

  startBtn.addEventListener("click", (e)=>{ e.preventDefault(); e.stopPropagation(); doStart(); }, {passive:false});
  startBtn.addEventListener("touchend", (e)=>{ e.preventDefault(); e.stopPropagation(); doStart(); }, {passive:false});
})();
</script>
</body>
</html>
