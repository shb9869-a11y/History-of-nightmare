<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,interactive-widget=resizes-content">
<title>From Emptiness (空) to Togetherness (共)</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="EMPTINESS→TOGETHERNESS">
<meta name="theme-color" content="#000000">

<!-- ✅ BOX DETECT libs -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>

<style>
:root{
  --frame: clamp(16px, 4vmin, 40px);
  --ui-gap: 8px;
  --fs-strong: clamp(14px, 2.8vmin, 18px);
  --fs-small: clamp(11px, 1.8vmin, 13px);
  --pad-btn-y: clamp(8px, 1.1vmin, 12px);
  --pad-btn-x: clamp(12px, 1.8vmin, 20px);
  --safe-t: env(safe-area-inset-top, 0px);
  --safe-b: env(safe-area-inset-bottom, 0px);
  --safe-l: env(safe-area-inset-left, 0px);
  --safe-r: env(safe-area-inset-right, 0px);

  /* ✅ 레퍼런스 톤 */
  --ink: #c9cfab;      /* 연녹빛 세리프 */
  --ink-dim: rgba(201,207,171,.78);
  --red: #b3342b;      /* 안내 레드 */
  --white: #f5f5f5;
}

html,body{
  margin:0; padding:0; width:100%; height:100%;
  background:#000; overflow:hidden;
  touch-action:manipulation;
}
body{
  font-family: ui-serif, "Iowan Old Style", "Palatino Linotype", Palatino, "Times New Roman", Times, serif;
  -webkit-user-select:none; user-select:none;
  -webkit-touch-callout:none;
  color:var(--ink);
}
*{
  box-sizing:border-box;
  -webkit-user-select:none; user-select:none;
  -webkit-touch-callout:none;
  -webkit-tap-highlight-color: transparent;
}

.fade{opacity:0; transition:opacity 900ms ease}
.fade.show{opacity:1}

#bg{
  position:fixed; inset:0;
  width:100vw; height:100vh;
  z-index:0;
  display:block;
}
#view{
  position:fixed; inset:0;
  width:100vw; height:100vh;
  z-index:1;
  display:block;
  filter:grayscale(1);
  opacity:0;
  pointer-events:none;
  transition:opacity 900ms ease;
}
#view.show{ opacity:1; }

#freezeLayer{
  position:fixed; inset:0;
  z-index:500;
  display:none;
}

.frameBox{
  position:fixed;
  left:calc(var(--frame) + var(--safe-l));
  top:calc(var(--frame) + var(--safe-t));
  right:calc(var(--frame) + var(--safe-r));
  bottom:calc(var(--frame) + var(--safe-b));
  border:2px solid rgba(245,245,245,.65);
  pointer-events:none;
  z-index:50;
}

.uiBtn{
  background:transparent;
  color:var(--white);
  border:none;
  font-size:var(--fs-strong);
  padding:var(--pad-btn-y) var(--pad-btn-x);
  font-family: inherit;
  letter-spacing: .08em;
  white-space:nowrap;
  cursor:pointer;
}
.uiBtn.small{
  font-size:var(--fs-small);
  padding:calc(var(--pad-btn-y)*0.75) calc(var(--pad-btn-x)*0.75);
}
.uiBtn[disabled]{ opacity:.35; pointer-events:none; filter:grayscale(1); }

.controls{
  position:fixed;
  right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
  bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
  z-index:400;
  display:flex;
  gap:6px;
  align-items:center;
  opacity:0;
  transition:opacity 900ms ease;
}
.controls.show{opacity:1}
.readout{
  min-width:64px;
  text-align:center;
  opacity:.9;
  font-size:var(--fs-small);
  color:var(--white);
  font-family: inherit;
}

.btn-capture{
  position:fixed;
  left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
  bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
  z-index:450;
  opacity:0;
  transition:opacity 900ms ease;
}
.btn-capture.show{opacity:1}

.sleep-status-text{
  position:fixed;
  left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
  bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b) + 34px);
  z-index:451;
  font-size:var(--fs-small);
  color:#f7f7f7;
  text-shadow:0 0 4px rgba(0,0,0,0.85);
  max-width:min(76vw, 720px);
}

/* =========================
   ✅ 전체 인트로/안내 오버레이
   ========================= */
#stage{
  position:fixed; inset:0;
  z-index:300;
  display:flex;
  align-items:stretch;
  justify-content:stretch;
  background: radial-gradient(1200px 700px at 50% 55%, rgba(255,255,255,.06), rgba(0,0,0,.92) 65%, rgba(0,0,0,.98));
  backdrop-filter: blur(0px);
}
#stage.hidden{
  opacity:0;
  pointer-events:none;
  transition:opacity 900ms ease;
}
#stageTap{
  position:absolute; inset:0;
  cursor:pointer;
}

/* 텍스트 블록들 */
.stageBlock{
  position:absolute;
  max-width:min(88vw, 980px);
  line-height:1.55;
  letter-spacing:.01em;
  text-shadow:0 0 10px rgba(0,0,0,.35);
}
.stageTitle{
  font-size:clamp(22px, 4.4vmin, 54px);
  letter-spacing:.01em;
  margin:0 0 10px 0;
  color:var(--ink);
}
.stageSub{
  font-size:clamp(14px, 2.2vmin, 20px);
  color:var(--ink-dim);
  margin:0;
}

/* 페이지별 배치 */
.pos-top-right{
  top:calc(var(--frame) + 10px + var(--safe-t));
  right:calc(var(--frame) + 10px + var(--safe-r));
  text-align:left;
}
.pos-bottom-left{
  left:calc(var(--frame) + 10px + var(--safe-l));
  bottom:calc(var(--frame) + 62px + var(--safe-b));
  text-align:left;
}
.pos-center{
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  text-align:center;
}

.stageLines{
  font-size:clamp(16px, 2.8vmin, 28px);
  color:var(--ink);
  white-space:pre-wrap;
}
.stageLines.small{
  font-size:clamp(14px, 2.2vmin, 20px);
  color:var(--ink);
}

/* 한 줄씩 나타나는 느낌 */
.line{
  opacity:0;
  transform: translateY(6px);
  transition: opacity 700ms ease, transform 700ms ease;
}
.line.show{
  opacity:1;
  transform: translateY(0px);
}

/* 빨간 안내 문구 */
.tapHint{
  position:absolute;
  left:50%;
  bottom:calc(var(--frame) + 14px + var(--safe-b));
  transform:translateX(-50%);
  font-size:clamp(12px, 2.0vmin, 16px);
  letter-spacing:.08em;
  color:rgba(179,52,43,.92);
  text-shadow:0 0 12px rgba(0,0,0,.55);
  opacity:.95;
  user-select:none;
}

/* 카운트다운 */
#countdown{
  position:absolute;
  left:50%; top:50%;
  transform:translate(-50%,-50%);
  font-size:clamp(42px, 9vmin, 92px);
  color:var(--ink);
  letter-spacing:.02em;
  opacity:0;
  transition:opacity 400ms ease;
}
#countdown.show{opacity:1}

/* =========================
   ✅ BOX DETECT UI - 메뉴만 (라운드 흰 테두리 제거)
   ========================= */
#toggleUI{
  position:fixed;
  right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
  top:calc(var(--frame) + var(--ui-gap) + var(--safe-t));
  z-index:920;
  background:transparent;
  border:none;              /* ✅ 흰 라운드 틀 제거 */
  padding:8px 10px;
  pointer-events:auto;
  color:rgba(245,245,245,.92);
  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  letter-spacing:.18em;
  font-size:12px;
  opacity:.85;
}
#toggleUI:active{transform:translateY(1px);}

#ui{
  position:fixed;
  right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
  top:calc(var(--frame) + var(--ui-gap) + var(--safe-t) + 34px);
  z-index:910;

  width:min(320px, calc(100vw - (var(--frame)*2) - 24px));
  max-height:calc(100vh - (var(--frame)*2) - 120px);
  overflow:auto;

  background:rgba(0,0,0,.42);
  border:1px solid rgba(255,255,255,.14);
  border-radius:16px;
  padding:12px;
  backdrop-filter: blur(10px);

  display:flex;
  flex-direction:column;
  gap:10px;
  pointer-events:auto;
  transition:.2s;

  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}
#ui.hidden{opacity:0; pointer-events:none; transform:translateY(-10px);}

.pill{
  display:grid;
  grid-template-columns: 92px 1fr auto;
  gap:10px;
  align-items:center;
  background:rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  padding:10px 12px;
  color:#ddd;
}
.pill b{color:#fff; font-weight:800; letter-spacing:.02em;}
.pill input[type=range]{width:100%;}
.pill label{
  grid-column: 1 / -1;
  display:flex;
  align-items:center;
  gap:10px;
}
#ui button{
  appearance:none;
  border:1px solid rgba(255,255,255,.18);
  background:rgba(255,255,255,.08);
  color:#fff;
  padding:10px 12px;
  border-radius:14px;
  font-weight:800;
  pointer-events:auto;
}
#ui button:active{transform:translateY(1px);}

#log{
  position:fixed;
  left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
  top:calc(var(--frame) + var(--ui-gap) + var(--safe-t));
  z-index:905;
  font-size:12px;
  background:rgba(0,0,0,.28);
  border:1px solid rgba(255,255,255,.10);
  border-radius:12px;
  padding:6px 10px;
  backdrop-filter: blur(10px);
  max-width:min(86vw,820px);
  white-space:pre-wrap;
  pointer-events:none;
  color:#ddd;
  opacity:0;
  transition:opacity 900ms ease;
  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}
#log.show{opacity:1;}
</style>
</head>

<body>
  <!-- ✅ 배경(인트로/안내에서 꿈틀거리는 점/선) -->
  <canvas id="bg"></canvas>

  <!-- ✅ 본편(카메라+박스) -->
  <canvas id="view"></canvas>
  <canvas id="freezeLayer"></canvas>

  <div class="frameBox" aria-hidden="true"></div>

  <div class="controls" id="controls">
    <button class="uiBtn small" id="zoomOut">–</button>
    <div class="readout"><span id="zoomVal">1.0×</span></div>
    <button class="uiBtn small" id="zoomIn">+</button>
  </div>

  <button id="captureBtn" class="uiBtn small btn-capture">Capture</button>
  <div id="sleepPhotoStatus" class="sleep-status-text"></div>

  <!-- ✅ BOX DETECT UI -->
  <button id="toggleUI" aria-label="menu">MENU</button>
  <div id="ui" class="hidden">
    <div class="pill">
      <b>COARSE</b>
      <input id="conf" type="range" min="0.01" max="0.95" step="0.01" value="0.12">
      <span id="confVal">0.12</span>
    </div>

    <div class="pill">
      <b>FINE</b>
      <input id="fine" type="range" min="0.00" max="1.00" step="0.01" value="0.40">
      <span id="fineVal">0.40</span>
    </div>

    <div class="pill">
      <b>N</b>
      <input id="topN" type="range" min="3" max="8" step="1" value="4">
      <span id="topNVal">4</span>
    </div>

    <div class="pill">
      <b>HOLD</b>
      <input id="holdSec" type="range" min="1" max="10" step="0.5" value="3.0">
      <span id="holdVal">3.0s</span>
    </div>

    <div class="pill">
      <b>BOX</b>
      <input id="boxScale" type="range" min="0.35" max="1.20" step="0.01" value="0.88">
      <span id="boxScaleVal">0.88</span>
    </div>

    <div class="pill">
      <label><input id="links" type="checkbox" checked> Links</label>
      <label><input id="fillFrag" type="checkbox" checked> Fragments</label>
    </div>

    <div class="pill" style="grid-template-columns: 1fr 1fr; gap:10px;">
      <button id="flip">Flip</button>
      <button id="restart">Restart</button>
    </div>

    <div class="pill" style="grid-template-columns: 92px 1fr; gap:10px;">
      <b>Source</b>
      <div style="display:flex; gap:10px; align-items:center; justify-content:flex-end;">
        <label style="display:flex; align-items:center; gap:8px;">
          <input id="videoFile" type="file" accept="video/*" style="max-width:160px;">
          <span style="opacity:.9">Upload</span>
        </label>
        <button id="useCam">Camera</button>
      </div>
    </div>

    <div class="pill" style="grid-template-columns: 1fr; gap:6px;">
      <span id="status">Idle</span>
      <span id="fps">FPS -</span>
      <span id="count">Boxes 0</span>
    </div>
  </div>

  <div id="log">ready</div>

  <!-- ✅ 인트로/안내 “탭으로 진행” 스테이지 -->
  <div id="stage" class="fade show">
    <div id="stageTap" aria-label="tap to continue"></div>

    <!-- 현재 페이지 텍스트 -->
    <div id="blkTitle" class="stageBlock pos-center" style="display:none;">
      <h1 class="stageTitle" style="margin-bottom:10px;">From Emptiness (空) to Togetherness (共)</h1>
      <p class="stageSub">A Cooking–Memory–Spatial Experiment in Reconstructing Empathy</p>
    </div>

    <div id="blkTR" class="stageBlock pos-top-right" style="display:none;">
      <div id="linesTR" class="stageLines small"></div>
    </div>

    <div id="blkBL" class="stageBlock pos-bottom-left" style="display:none;">
      <div id="linesBL" class="stageLines small"></div>
    </div>

    <div id="blkCenter" class="stageBlock pos-center" style="display:none;">
      <div id="linesCenter" class="stageLines"></div>
    </div>

    <div id="countdown">10</div>
    <div id="tapHint" class="tapHint">TAP ANYWHERE TO CONTINUE</div>
  </div>

<script>
(() => {
  /* =========================
     ✅ 업로드 서버 설정
     ========================= */
  const SLEEP_UPLOAD_SERVER = 'https://172.16.14.60:4443';
  const UPLOAD_TIMEOUT_MS = 12000;
  const UPLOAD_RETRY = 1;

  /* =========================
     ✅ 배경 음악 (폴더: ./audio/bgm.mp3)
     ========================= */
  const BGM_SRC = "audio/bgm.mp3";
  const BGM_VOLUME = 0.55;
  let bgm = null;
  function startBgm(){
    try{
      if(!bgm){
        bgm = new Audio(BGM_SRC);
        bgm.loop = true;
        bgm.preload = "auto";
        bgm.volume = BGM_VOLUME;
      }
      // iOS 정책상 "사용자 제스처" 안에서 play() 해야 함
      bgm.play().catch(()=>{});
    }catch(e){}
  }

  /* =========================
     기본 유틸
     ========================= */
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const qs = s => document.querySelector(s);
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

  document.addEventListener('contextmenu', e=>e.preventDefault());
  document.addEventListener('selectstart', e=>e.preventDefault());

  /* =========================
     SFX(탭 클릭음 - 아주 얇게)
     ========================= */
  let audioCtx = null;
  function ensureAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  async function ensureResumed(){
    ensureAudio();
    if(audioCtx.state === 'suspended'){
      try{ await audioCtx.resume(); }catch(e){}
    }
  }
  const MASTER_SFX_GAIN = 0.08;
  async function playTap(){
    try{
      await ensureResumed();
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type='sine';
      o.frequency.setValueAtTime(190, now);
      o.frequency.exponentialRampToValueAtTime(130, now+0.10);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(MASTER_SFX_GAIN, now+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now+0.14);
      o.connect(g).connect(audioCtx.destination);
      o.start(now);
      o.stop(now+0.16);
    }catch(e){}
  }

  /* =========================
     DOM
     ========================= */
  const bg = qs('#bg');
  const view = qs('#view');
  const freezeLayer = qs('#freezeLayer');

  const stage = qs('#stage');
  const stageTap = qs('#stageTap');
  const tapHint = qs('#tapHint');

  const blkTitle = qs('#blkTitle');
  const blkTR = qs('#blkTR');
  const blkBL = qs('#blkBL');
  const blkCenter = qs('#blkCenter');

  const linesTR = qs('#linesTR');
  const linesBL = qs('#linesBL');
  const linesCenter = qs('#linesCenter');
  const countdownEl = qs('#countdown');

  const controls = qs('#controls');
  const zoomIn = qs('#zoomIn');
  const zoomOut = qs('#zoomOut');
  const zoomVal = qs('#zoomVal');
  const captureBtn = qs('#captureBtn');

  const sleepPhotoStatus = qs('#sleepPhotoStatus');
  function setSleepPhotoStatus(msg){ sleepPhotoStatus.textContent = msg || ''; }

  const toggleUIBtn = qs('#toggleUI');
  const ui = qs('#ui');
  const logEl = qs('#log');

  const confEl = qs('#conf');
  const confVal = qs('#confVal');
  const fineEl = qs('#fine');
  const fineVal = qs('#fineVal');
  const topNEl = qs('#topN');
  const topNVal = qs('#topNVal');
  const holdSecEl = qs('#holdSec');
  const holdValEl = qs('#holdVal');
  const boxScaleEl = qs('#boxScale');
  const boxScaleValEl = qs('#boxScaleVal');

  const linksEl = qs('#links');
  const fillFragEl = qs('#fillFrag');

  const flipBtn = qs('#flip');
  const restartBtn = qs('#restart');
  const useCamBtn = qs('#useCam');
  const videoFileEl = qs('#videoFile');

  const statusEl = qs('#status');
  const fpsEl = qs('#fps');
  const countEl = qs('#count');

  function log(msg){ logEl.textContent = String(msg); }

  toggleUIBtn.addEventListener('click', ()=>{
    const hidden = ui.classList.toggle('hidden');
    toggleUIBtn.textContent = hidden ? 'MENU' : 'CLOSE';
    playTap();
  }, {passive:true});

  /* =========================
     ✅ 배경(점/선) 애니메이션
     ========================= */
  const bctx = bg.getContext('2d', {alpha:false});
  let B = {w:0,h:0,dpr:1};

  function resizeBG(){
    const dpr = window.devicePixelRatio||1;
    const w = innerWidth, h = innerHeight;
    bg.width = Math.round(w*dpr);
    bg.height = Math.round(h*dpr);
    bctx.setTransform(dpr,0,0,dpr,0,0);
    B = {w,h,dpr};
  }
  window.addEventListener('resize', resizeBG, {passive:true});
  window.addEventListener('orientationchange', resizeBG, {passive:true});
  resizeBG();

  const PNUM = 62;
  const pts = [];
  for(let i=0;i<PNUM;i++){
    pts.push({
      x: Math.random()*innerWidth,
      y: Math.random()*innerHeight,
      vx: (Math.random()-0.5)*0.18,
      vy: (Math.random()-0.5)*0.18,
      r: 1.2 + Math.random()*1.8,
      ph: Math.random()*Math.PI*2
    });
  }

  function bgLoop(){
    const W = B.w, H = B.h;
    const t = performance.now()*0.001;

    // 바탕
    bctx.fillStyle = '#000';
    bctx.fillRect(0,0,W,H);

    // 은은한 비네팅
    const g = bctx.createRadialGradient(W*0.5,H*0.55, 10, W*0.5,H*0.55, Math.max(W,H)*0.9);
    g.addColorStop(0, 'rgba(255,255,255,0.05)');
    g.addColorStop(0.55,'rgba(0,0,0,0.78)');
    g.addColorStop(1, 'rgba(0,0,0,0.98)');
    bctx.fillStyle = g;
    bctx.fillRect(0,0,W,H);

    // 이동(꿈틀)
    for(const p of pts){
      const wob = 0.22 * Math.sin(t*0.7 + p.ph);
      p.x += p.vx + wob*0.02;
      p.y += p.vy + wob*0.02;

      if(p.x< -60) p.x = W+60;
      if(p.x> W+60) p.x = -60;
      if(p.y< -60) p.y = H+60;
      if(p.y> H+60) p.y = -60;
    }

    // 링크
    bctx.save();
    bctx.globalAlpha = 0.9;
    for(let i=0;i<pts.length;i++){
      for(let j=i+1;j<pts.length;j++){
        const a=pts[i], b=pts[j];
        const dx=a.x-b.x, dy=a.y-b.y;
        const d2=dx*dx+dy*dy;
        const maxD = Math.min(W,H)*0.22;
        if(d2 < maxD*maxD){
          const d = Math.sqrt(d2);
          const alpha = 0.22*(1 - d/maxD) + 0.02;
          bctx.strokeStyle = `rgba(245,245,245,${alpha.toFixed(3)})`;
          bctx.lineWidth = 1.0 + 0.6*Math.sin(t*0.9 + i*0.3);
          bctx.beginPath();
          bctx.moveTo(a.x,a.y);
          bctx.lineTo(b.x,b.y);
          bctx.stroke();
        }
      }
    }
    bctx.restore();

    // 점
    bctx.save();
    for(const p of pts){
      const pulse = 0.55 + 0.45*Math.sin(t*1.1 + p.ph);
      bctx.fillStyle = `rgba(245,245,245,${(0.35 + 0.35*pulse).toFixed(3)})`;
      bctx.beginPath();
      bctx.arc(p.x,p.y,p.r*(0.85+0.25*pulse),0,Math.PI*2);
      bctx.fill();
    }
    bctx.restore();

    requestAnimationFrame(bgLoop);
  }
  requestAnimationFrame(bgLoop);

  /* =========================
     ✅ 스테이지(권한 → 타이틀 → 안내 페이지 → 카운트다운)
     ========================= */

  // 페이지 정의: 위치 + 문장들
  const PAGES = [
    {
      kind:"PERMISSION",
      showTitle:false,
      pos:"CENTER",
      lines:[
        "Camera permission is required.",
      ],
      hint:"TAP ANYWHERE TO ALLOW CAMERA"
    },
    {
      kind:"TITLE",
      showTitle:true,
      pos:"CENTER",
      lines:[],
      hint:"TAP ANYWHERE TO ENTER"
    },
    {
      kind:"TR",
      showTitle:false,
      pos:"TR",
      lines:[
`Empathy originally refers to the ability to feel with others (共感).
In contemporary relational structures, however, this sense of togetherness has weakened,
shifting toward emptiness, disconnection, and absence (空).`,
"",
`This project begins at that point of rupture and explores whether emotions emptied of togetherness
can be reconstructed through cooking—the oldest bodily gesture of care.`,
"",
`Can the oldest gesture of care—cooking—restore emotions that have become empty of togetherness?`
      ],
      hint:"TAP ANYWHERE TO READ NEXT"
    },
    {
      kind:"BL",
      showTitle:false,
      pos:"BL",
      lines:[
`In contemporary society, empathy is often reduced to superficial reactions within accelerated communication.`,
"",
`Emotional connection weakens, leaving growing gaps between individuals.`,
"",
`This project treats that gap not as failure,
but as a starting point for reconstruction.`
      ],
      hint:"TAP ANYWHERE TO READ NEXT"
    },
    {
      kind:"TR2",
      showTitle:false,
      pos:"TR",
      lines:[
`This performance-installation involves two artists who build an archive through remote workshops—recipes, memories, writing, and cooking videos—then translate it on-site into a miniature world (cooking table) and a live performance that shares shifting states of empathy (共感) with the audience.`,
"",
`The focus is not cooking itself, but the gesture—the subtle bodily vibration that emerges while following unfamiliar recipes, moving from estrangement to understanding and empathy.`
      ],
      hint:"TAP ANYWHERE TO READ NEXT"
    },
    {
      kind:"CENTER",
      showTitle:false,
      pos:"CENTER",
      lines:[
`WHY COOKING / WHY RECIPE`,
"",
`Cooking is both survival and a time-intensive gesture of care.
Recipes inherited from parents often embed personal emotional memory—nostalgia, longing, loss, attachment.
This project treats recipes as both an emotional document and a performance score,`,
"",
`testing how empathy can be reconstructed through exchanging, transforming, performing, and archiving them.`
      ],
      hint:"TAP ANYWHERE TO CONTINUE"
    },
    {
      kind:"COUNTDOWN",
      showTitle:false,
      pos:"CENTER",
      lines:[
        "Enjoy the exhibition."
      ],
      hint:"STARTING IN 10"
    }
  ];

  let stageIndex = 0;
  let lineIndex = 0;
  let locked = false;
  let cameraPermissionAsked = false;

  function clearStageBlocks(){
    blkTitle.style.display = "none";
    blkTR.style.display = "none";
    blkBL.style.display = "none";
    blkCenter.style.display = "none";
    linesTR.innerHTML = "";
    linesBL.innerHTML = "";
    linesCenter.innerHTML = "";
    countdownEl.classList.remove("show");
    countdownEl.textContent = "10";
  }

  function mountLines(el, lines){
    // lines: 배열(문단 단위) → 각 항목을 "한 줄"처럼 보여주되, 빈줄은 스페이서로 처리
    el.innerHTML = "";
    const nodes = [];
    for(const s of lines){
      const div = document.createElement("div");
      div.className = "line";
      div.textContent = s === "" ? " " : s;
      el.appendChild(div);
      nodes.push(div);
    }
    return nodes;
  }

  let currentNodes = [];

  function showLine(i){
    if(!currentNodes[i]) return;
    currentNodes[i].classList.add("show");
  }

  async function fadeStageOutIn(fn){
    stage.classList.remove("show");
    stage.classList.add("fade");
    await sleep(450);
    fn && fn();
    await sleep(30);
    stage.classList.add("show");
  }

  function renderStage(){
    clearStageBlocks();

    const page = PAGES[stageIndex];
    tapHint.textContent = page.hint || "TAP ANYWHERE";

    if(page.kind==="TITLE"){
      blkTitle.style.display = "block";
      currentNodes = [];
      lineIndex = 0;
      return;
    }

    if(page.kind==="PERMISSION"){
      blkCenter.style.display = "block";
      currentNodes = mountLines(linesCenter, page.lines);
      lineIndex = 0;
      // 첫 줄은 자동 페이드
      showLine(0);
      return;
    }

    if(page.kind==="TR"){
      blkTR.style.display = "block";
      currentNodes = mountLines(linesTR, page.lines);
      lineIndex = 0;
      showLine(0);
      return;
    }

    if(page.kind==="BL"){
      blkBL.style.display = "block";
      currentNodes = mountLines(linesBL, page.lines);
      lineIndex = 0;
      showLine(0);
      return;
    }

    if(page.kind==="TR2"){
      blkTR.style.display = "block";
      currentNodes = mountLines(linesTR, page.lines);
      lineIndex = 0;
      showLine(0);
      return;
    }

    if(page.kind==="CENTER"){
      blkCenter.style.display = "block";
      currentNodes = mountLines(linesCenter, page.lines);
      lineIndex = 0;
      showLine(0);
      return;
    }

    if(page.kind==="COUNTDOWN"){
      blkCenter.style.display = "block";
      currentNodes = mountLines(linesCenter, page.lines);
      lineIndex = 0;
      showLine(0);
      return;
    }
  }

  async function advanceStageTap(){
    if(locked) return;
    locked = true;

    await ensureResumed();
    startBgm();          // ✅ 첫 탭부터 bgm 시도
    playTap();

    const page = PAGES[stageIndex];

    // 1) 권한 페이지: 첫 탭에서 카메라 권한 요청
    if(page.kind==="PERMISSION"){
      if(!cameraPermissionAsked){
        cameraPermissionAsked = true;
        try{
          const s = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
          s.getTracks().forEach(t=>t.stop());
        }catch(e){
          // 권한 거부여도 “탭 진행”은 가능하게 (다만 본편 시작 때 카메라 실패 뜰 수 있음)
        }
      }
      // 다음 탭에서 타이틀로 넘어가도록
      await fadeStageOutIn(()=>{ stageIndex++; renderStage(); });
      locked = false;
      return;
    }

    // 2) 타이틀: 탭하면 안내 문장 시작
    if(page.kind==="TITLE"){
      await fadeStageOutIn(()=>{ stageIndex++; renderStage(); });
      locked = false;
      return;
    }

    // 3) 안내 페이지: 한 줄씩 show → 다 보여주면 다음 페이지로 페이드
    if(page.kind!=="COUNTDOWN"){
      // 다음 줄 표시
      const next = lineIndex + 1;
      if(next < currentNodes.length){
        lineIndex = next;
        showLine(lineIndex);
        locked = false;
        return;
      }else{
        // 페이지 종료 → 다음 페이지
        await fadeStageOutIn(()=>{ stageIndex++; renderStage(); });
        locked = false;
        return;
      }
    }

    // 4) 카운트다운 페이지: 탭하면 10초 카운트다운 시작 후 본편 진입
    if(page.kind==="COUNTDOWN"){
      tapHint.textContent = "STARTING…";
      countdownEl.classList.add("show");

      let n = 10;
      countdownEl.textContent = String(n);
      for(let i=0;i<10;i++){
        await sleep(1000);
        n--;
        countdownEl.textContent = String(n);
      }

      // 스테이지 종료 → 본편 시작
      await endStageAndStartExperience();
      locked = false;
      return;
    }

    locked = false;
  }

  // 탭 이벤트(어디든)
  ['click','touchstart','pointerdown'].forEach(type=>{
    stageTap.addEventListener(type, (e)=>{ e.preventDefault(); advanceStageTap(); }, {passive:false});
  });

  // 최초 렌더
  renderStage();

  /* =========================
     ✅ 본편(BOX DETECT) - 기존 코드 유지 + “stage 끝난 뒤” 시작
     ========================= */

  const vctx = view.getContext('2d', { alpha:false });

  let camStream=null;
  let camVideo=null;
  let facingMode='environment';
  let usingUploadVideo=false;

  let ZOOM=1.0;
  let showCamera=false;
  let camFadeAlpha=0;

  function updateZoomLabel(){ zoomVal.textContent = ZOOM.toFixed(1)+'×'; }
  updateZoomLabel();

  zoomIn.addEventListener('click', async ()=>{
    await ensureResumed();
    ZOOM=Math.min(3.0, ZOOM+0.1);
    updateZoomLabel();
    playTap();
  }, {passive:true});

  zoomOut.addEventListener('click', async ()=>{
    await ensureResumed();
    ZOOM=Math.max(1.0, ZOOM-0.1);
    updateZoomLabel();
    playTap();
  }, {passive:true});

  function resizeView(){
    const dpr=window.devicePixelRatio||1;
    const w=window.innerWidth;
    const h=window.innerHeight;
    view.width=w*dpr;
    view.height=h*dpr;
    vctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resizeView, {passive:true});
  window.addEventListener('orientationchange', resizeView, {passive:true});
  resizeView();

  async function startCameraFresh(){
    usingUploadVideo=false;
    if (camStream){
      camStream.getTracks().forEach(t=>t.stop());
      camStream=null;
    }
    const s = await navigator.mediaDevices.getUserMedia({
      video:{
        facingMode:{ideal:facingMode},
        width:{min:1280,ideal:1920},
        height:{min:720,ideal:1080},
        aspectRatio:{ideal:16/9}
      },
      audio:false
    });
    camStream = s;

    if(!camVideo){
      camVideo=document.createElement('video');
      camVideo.setAttribute('playsinline','');
      camVideo.autoplay=true;
      camVideo.playsInline=true;
      camVideo.muted=true;
    }
    camVideo.srcObject=camStream;
    camVideo.src = '';
    await camVideo.play().catch(()=>{});
    if (camVideo.readyState < 1){
      await new Promise(res=>camVideo.addEventListener('loadedmetadata', res, {once:true}));
    }
  }

  async function useUploadedVideo(file){
    usingUploadVideo=true;
    if (camStream){
      camStream.getTracks().forEach(t=>t.stop());
      camStream=null;
    }
    if(!camVideo){
      camVideo=document.createElement('video');
      camVideo.setAttribute('playsinline','');
      camVideo.autoplay=true;
      camVideo.playsInline=true;
      camVideo.muted=true;
    }
    camVideo.srcObject=null;
    camVideo.loop=true;
    camVideo.muted=true;
    camVideo.src = URL.createObjectURL(file);
    await camVideo.play().catch(()=>{});
    if (camVideo.readyState < 1){
      await new Promise(res=>camVideo.addEventListener('loadedmetadata', res, {once:true}));
    }
  }

  function fadeInCamera(dur=900){
    showCamera = true;
    const start = performance.now();
    camFadeAlpha = 0;
    function step(){
      const t = (performance.now() - start) / dur;
      camFadeAlpha = clamp(t, 0, 1);
      if(t < 1 && showCamera) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  function getCameraDrawTransform(){
    const w = view.clientWidth || innerWidth;
    const h = view.clientHeight || innerHeight;

    if(!camVideo || camVideo.readyState < 2) return null;
    const vw = camVideo.videoWidth, vh = camVideo.videoHeight;
    if(!vw || !vh) return null;

    const fw = w, fh = h;
    const videoRatio = vw / vh;
    const frameRatio = fw / fh;

    let dw, dh;
    if(videoRatio > frameRatio){ dh = fh; dw = dh * videoRatio; }
    else { dw = fw; dh = dw / videoRatio; }

    dw *= ZOOM; dh *= ZOOM;
    const dx = (fw - dw)/2;
    const dy = (fh - dh)/2;

    return { vw, vh, dx, dy, dw, dh, fw, fh };
  }

  /* =========================
     ✅ 업로드 (그대로)
     ========================= */
  function humanErr(e){
    const msg = (e && e.message) ? e.message : String(e);
    if (/aborted/i.test(msg)) return "timeout";
    return msg;
  }

  async function canvasToJpegBlobResized(srcCanvas, maxLongSide=1600, quality=0.85){
    const w = srcCanvas.width;
    const h = srcCanvas.height;
    if (!w || !h) return null;

    const longSide = Math.max(w,h);
    const scale = Math.min(1, maxLongSide / longSide);

    const tw = Math.max(1, Math.round(w * scale));
    const th = Math.max(1, Math.round(h * scale));

    let target = srcCanvas;
    if (scale < 0.999){
      const c = document.createElement("canvas");
      c.width = tw;
      c.height = th;
      const cctx = c.getContext("2d");
      cctx.imageSmoothingEnabled = true;
      cctx.imageSmoothingQuality = "high";
      cctx.drawImage(srcCanvas, 0,0,w,h, 0,0,tw,th);
      target = c;
    }

    const blob = await new Promise((resolve) => {
      target.toBlob((b)=>resolve(b), "image/jpeg", quality);
    });

    return blob;
  }

  async function fetchWithTimeout(url, options={}, timeoutMs=UPLOAD_TIMEOUT_MS){
    const controller = new AbortController();
    const id = setTimeout(()=>controller.abort(new Error("aborted")), timeoutMs);
    try{
      const res = await fetch(url, { ...options, signal: controller.signal });
      return res;
    } finally {
      clearTimeout(id);
    }
  }

  async function uploadBlob(blob){
    const formData = new FormData();
    formData.append("image", blob, `sleep_capture_${Date.now()}.jpg`);

    const base = (SLEEP_UPLOAD_SERVER && SLEEP_UPLOAD_SERVER.trim()) ? SLEEP_UPLOAD_SERVER.trim() : '';
    const url = base + "/upload";

    let res = await fetchWithTimeout(url, { method:"POST", body: formData }, UPLOAD_TIMEOUT_MS);

    if ((!res.ok && res.status >= 500) && UPLOAD_RETRY > 0){
      await new Promise(r=>setTimeout(r, 400));
      res = await fetchWithTimeout(url, { method:"POST", body: formData }, UPLOAD_TIMEOUT_MS);
    }

    return res;
  }

  async function uploadSnapshotCanvas(canvas){
    try{
      setSleepPhotoStatus('Uploading...');
      const blob = await canvasToJpegBlobResized(canvas, 1600, 0.85);
      if(!blob){
        setSleepPhotoStatus('Upload error: blob null');
        return;
      }

      const res = await uploadBlob(blob);

      if(!res.ok){
        const txt = await res.text().catch(()=> "");
        setSleepPhotoStatus(`Upload failed: ${res.status}${txt ? " / " + txt.slice(0,80) : ""}`);
        return;
      }

      const ct = res.headers.get("content-type") || "";
      if (ct.includes("application/json")){
        await res.json().catch(()=>({}));
      } else {
        await res.text().catch(()=> "");
      }

      setSleepPhotoStatus('Uploaded');
      setTimeout(()=>setSleepPhotoStatus(''), 3500);
    }catch(err){
      console.error("UPLOAD ERROR RAW:", err);
      setSleepPhotoStatus('Upload error: ' + humanErr(err));
      setTimeout(()=>setSleepPhotoStatus(''), 6000);
    }
  }

  /* =========================
     ✅ BOX DETECT assets/labels (그대로)
     ========================= */
  const LIMEN_LABELS = ["Mom","Hometown","Son Duk-Geum","GrandFather","Ocean"];
  const CLASS_TO_LIMEN = {
    person: "Mom",
    diningtable: "Hometown",
    bottle: "Ocean",
    cup: "Hometown",
    fork: "Son Duk-Geum",
    knife: "Son Duk-Geum",
    spoon: "Son Duk-Geum",
    chair: "GrandFather",
    tv: "Ocean",
    laptop: "Ocean",
    "cell phone": "Ocean"
  };
  function pickLimenLabelByClass(cocoClass, fallbackIndex){
    return CLASS_TO_LIMEN[cocoClass] || LIMEN_LABELS[fallbackIndex % LIMEN_LABELS.length];
  }
  function shuffleCopy(arr){
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  const LABEL_COLOR = {
    "Mom": [255,140,140],
    "Hometown": [140,255,180],
    "Son Duk-Geum": [255,255,140],
    "GrandFather": [190,190,255],
    "Ocean": [140,190,255]
  };

  const ASSET_FILES = {
    "Mom": "assets/mom.jpg",
    "Hometown": "assets/hometown.jpg",
    "Son Duk-Geum": "assets/son-duk-geum.jpg",
    "GrandFather": "assets/grandfather.jpg",
    "Ocean": "assets/ocean.jpg"
  };

  const assets = new Map();
  async function loadAssets(){
    assets.clear();
    const entries = Object.entries(ASSET_FILES);
    for (const [label, path] of entries){
      const img = new Image();
      img.crossOrigin = "anonymous";
      const rec = { el:img, ready:false, path };
      assets.set(label, rec);
      await new Promise((res) => {
        img.onload = () => { rec.ready = true; res(); };
        img.onerror = () => { rec.ready = false; res(); };
        img.src = path + "?v=" + Date.now();
      });
    }
    const ok = [...assets.values()].filter(a=>a.ready).length;
    log(`assets: ${ok}/${entries.length}`);
  }

  /* =========================
     ✅ coco-ssd model
     ========================= */
  let model=null;
  async function loadModel(){
    if(model) return model;
    statusEl.textContent = "Loading";
    log("model loading...");
    model = await cocoSsd.load({ base:"lite_mobilenet_v2" });
    log("model loaded");
    return model;
  }

  function iou(a,b){
    const ax1=a[0], ay1=a[1], ax2=a[0]+a[2], ay2=a[1]+a[3];
    const bx1=b[0], by1=b[1], bx2=b[0]+b[2], by2=b[1]+b[3];
    const ix1=Math.max(ax1,bx1), iy1=Math.max(ay1,by1);
    const ix2=Math.min(ax2,bx2), iy2=Math.min(ay2,by2);
    const iw=Math.max(0, ix2-ix1), ih=Math.max(0, iy2-iy1);
    const inter=iw*ih;
    const ua=a[2]*a[3] + b[2]*b[3] - inter;
    return ua>0 ? inter/ua : 0;
  }
  function center(b){ return {x:b[0]+b[2]/2, y:b[1]+b[3]/2}; }
  function makeLinks(points, k=2){
    const links=[];
    for(let i=0;i<points.length;i++){
      const ds=[];
      for(let j=0;j<points.length;j++){
        if(i===j) continue;
        const dx=points[i].x-points[j].x, dy=points[i].y-points[j].y;
        ds.push({j, d:dx*dx+dy*dy});
      }
      ds.sort((a,b)=>a.d-b.d);
      for(let t=0;t<Math.min(k, ds.length);t++){
        const j=ds[t].j;
        if(i<j) links.push([i,j,ds[t].d]);
      }
    }
    return links;
  }
  function fract(x){ return x - Math.floor(x); }
  function scaleBox(bbox, s){
    const [x,y,w,h]=bbox;
    const cx = x + w/2, cy = y + h/2;
    const nw = w * s, nh = h * s;
    return [cx - nw/2, cy - nh/2, nw, nh];
  }

  function getLinkStyle(aLabel, bLabel, t){
    const pair = [aLabel, bLabel].sort().join("|");
    let widthMul = 1.0, alphaMul = 1.0, jitter = 0.0, dash = null, pulse = 0.0, glow = 0.0;

    if (aLabel==="Mom" || bLabel==="Mom"){ widthMul=1.35; alphaMul=1.20; pulse=0.18; }
    if (aLabel==="Ocean" || bLabel==="Ocean"){ alphaMul*=0.78; jitter=1.2; dash=[6,10]; }
    if (aLabel==="GrandFather" || bLabel==="GrandFather"){ pulse=Math.max(pulse,0.38); }
    if (aLabel==="Hometown" || bLabel==="Hometown"){ dash = dash || [10,6]; }
    if (aLabel==="Son Duk-Geum" || bLabel==="Son Duk-Geum"){ glow=0.7; }

    if (pair === "Hometown|Mom") alphaMul *= 1.10;
    if (pair === "GrandFather|Ocean") jitter *= 1.35;

    const pulseFactor = 1 + pulse * Math.sin(t*1.6);
    return { widthMul: widthMul*pulseFactor, alphaMul, jitter, dash, glow };
  }

  function drawFragmentIntoBox(assetRec, bbox, seed){
    if (!assetRec || !assetRec.ready) return;
    const [x,y,w,h] = bbox;
    if (w < 8 || h < 8) return;

    const t = performance.now() * 0.001;
    const r1 = fract(Math.sin(seed*12.9898 + t*1.3) * 43758.5453);
    const r2 = fract(Math.sin(seed*78.233  + t*0.9) * 12345.6789);
    const r3 = fract(Math.sin(seed*41.77   + t*1.7) * 98765.4321);

    vctx.save();
    vctx.beginPath(); vctx.rect(x,y,w,h); vctx.clip();

    const scale = 1.05 + r1 * 1.25;
    const ox = (r2 - 0.5) * w * 0.35;
    const oy = (r3 - 0.5) * h * 0.35;

    const el = assetRec.el;
    const sw = el.naturalWidth||0;
    const sh = el.naturalHeight||0;
    if (sw < 2 || sh < 2){ vctx.restore(); return; }

    const dw = w * scale, dh = h * scale;
    const dx = x + (w - dw)/2 + ox;
    const dy = y + (h - dh)/2 + oy;

    vctx.globalAlpha = 0.85;
    vctx.drawImage(el, dx, dy, dw, dh);

    vctx.globalAlpha = 0.32;
    const dw2 = w * (0.85 + r2*0.5);
    const dh2 = h * (0.85 + r3*0.5);
    const dx2 = x + (w - dw2)/2 - ox*0.25;
    const dy2 = y + (h - dh2)/2 - oy*0.25;
    vctx.drawImage(el, dx2, dy2, dw2, dh2);

    vctx.restore();
    vctx.globalAlpha = 1;
  }

  function drawLabelTag(label, cocoClass, x, y){
    const col = LABEL_COLOR[label] || [255,255,255];
    const text = `${label} · ${cocoClass}`;
    vctx.font = `${Math.max(12, Math.round((view.clientWidth||innerWidth)/95))}px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;
    vctx.textBaseline = "top";
    const padX = 7, padY = 4;
    const tw = vctx.measureText(text).width;
    const th = Math.max(18, Math.round((view.clientWidth||innerWidth)/75));

    const ty = Math.max(0, y - th - 2);
    vctx.fillStyle = "rgba(0,0,0,0.65)";
    vctx.fillRect(x, ty, tw + padX*2, th);

    vctx.fillStyle = `rgba(${col[0]},${col[1]},${col[2]},0.98)`;
    vctx.fillText(text, x + padX, ty + padY);
  }

  function computeMinAreaFromFine(fine, vw, vh){
    const base = vw * vh;
    const minRatio = 0.0015;
    const maxRatio = 0.12;
    const r = minRatio + (1 - fine) * (maxRatio - minRatio);
    return base * r;
  }

  let objectTracks = [];
  let renderTracks = [];
  let nextId = 1;

  function lerp(a,b,t){ return a+(b-a)*t; }
  function lerpBox(cur,target,t){
    return [lerp(cur[0],target[0],t),lerp(cur[1],target[1],t),lerp(cur[2],target[2],t),lerp(cur[3],target[3],t)];
  }

  function ensureDistinctLabelsForTopN(objs, nowMs){
    const holdMs = (+holdSecEl.value) * 1000;

    for (const o of objs){
      if (!o.label || nowMs > o.labelUntil) o.label = null;
    }

    const used = new Set(objs.filter(o=>o.label).map(o=>o.label));
    for (let i=0;i<objs.length;i++){
      const o = objs[i];
      if (!o.label){
        let candidate = pickLimenLabelByClass(o.cls, i);
        if (used.has(candidate)){
          const pool = shuffleCopy(LIMEN_LABELS).filter(L=>!used.has(L));
          if (pool.length) candidate = pool[0];
        }
        o.label = candidate;
        o.labelUntil = nowMs + holdMs;
        used.add(candidate);
      }
    }

    if (objs.length >= 3){
      let uniq = new Set(objs.map(o=>o.label));
      if (uniq.size < 3){
        const pool = shuffleCopy(LIMEN_LABELS).filter(L=>!uniq.has(L));
        const counts = {};
        objs.forEach(o=>{ counts[o.label]=(counts[o.label]||0)+1; });
        const dup = objs.slice().sort((a,b)=>(counts[b.label]||0)-(counts[a.label]||0));
        for (const o of dup){
          uniq = new Set(objs.map(x=>x.label));
          if (uniq.size >= 3) break;
          const next = pool.shift();
          if (!next) break;
          o.label = next;
          o.labelUntil = nowMs + holdMs;
        }
      }
    }
  }

  const DETECT_INTERVAL_MS = 240;
  let lastDetectAt = 0;
  let runningDetect = false;

  async function stepDetect(){
    if(!model) await loadModel();
    if(!camVideo || camVideo.readyState < 2) return;

    const coarse = +confEl.value;
    const fine = +fineEl.value;
    confVal.textContent = coarse.toFixed(2);
    fineVal.textContent = fine.toFixed(2);

    let wantN = +topNEl.value;
    wantN = clamp(wantN, 3, 8);
    topNVal.textContent = String(wantN);

    holdValEl.textContent = (+holdSecEl.value).toFixed(1) + "s";
    boxScaleValEl.textContent = (+boxScaleEl.value).toFixed(2);

    const vw = camVideo.videoWidth || 0;
    const vh = camVideo.videoHeight || 0;
    const minArea = computeMinAreaFromFine(fine, vw||1280, vh||720);

    let preds = await model.detect(camVideo);

    preds = preds
      .filter(p => (p.score >= coarse) && ((p.bbox[2]*p.bbox[3]) >= minArea))
      .sort((a,b) => b.score - a.score);

    const candidates = preds.slice(0, 12);
    const nowMs = performance.now();

    const used = new Set();
    for (const tr of objectTracks){
      let bestJ = -1, bestI = 0;
      for (let j=0;j<candidates.length;j++){
        if (used.has(j)) continue;
        const s = iou(tr.bbox, candidates[j].bbox);
        if (s > bestI){ bestI=s; bestJ=j; }
      }
      if (bestJ >= 0 && bestI > 0.18){
        const p = candidates[bestJ];
        used.add(bestJ);
        tr.bbox = lerpBox(tr.bbox, p.bbox, 0.55);
        tr.cls = p.class;
        tr.score = p.score;
        tr.lastSeen = nowMs;
      }
    }

    for (let j=0;j<candidates.length;j++){
      if (used.has(j)) continue;
      const p = candidates[j];
      objectTracks.push({
        id: nextId++,
        bbox: p.bbox.slice(),
        cls: p.class,
        score: p.score,
        label: null,
        labelUntil: 0,
        lastSeen: nowMs,
        seed: (nextId*971 + j*37) >>> 0
      });
    }

    objectTracks = objectTracks.filter(tr => (nowMs - tr.lastSeen) < 1200);
    objectTracks.sort((a,b)=>b.score-a.score);
    let active = objectTracks.slice(0, wantN);

    if (active.length < 3){
      const fallback = objectTracks.slice().sort((a,b)=>b.lastSeen-a.lastSeen).slice(0, Math.min(3, objectTracks.length));
      if (fallback.length >= 3) active = fallback;
    }

    renderTracks = active;
    ensureDistinctLabelsForTopN(renderTracks, nowMs);

    statusEl.textContent = (renderTracks.length < 3)
      ? ((usingUploadVideo ? "Upload" : "Camera") + " · need 3 objects")
      : (usingUploadVideo ? "Upload" : "Camera");
  }

  function mapVideoBoxToScreen(bbox, T){
    const [x,y,w,h] = bbox;
    const sx = T.dx + (x / T.vw) * T.dw;
    const sy = T.dy + (y / T.vh) * T.dh;
    const sw = (w / T.vw) * T.dw;
    const sh = (h / T.vh) * T.dh;
    return [sx, sy, sw, sh];
  }

  function drawCameraAndDetect(){
    const W = view.clientWidth || innerWidth;
    const H = view.clientHeight || innerHeight;

    vctx.save();
    vctx.fillStyle = '#000';
    vctx.fillRect(0,0,W,H);
    vctx.restore();

    const T = getCameraDrawTransform();
    if(showCamera && T){
      vctx.save();
      vctx.globalAlpha = camFadeAlpha;
      vctx.drawImage(camVideo, T.dx, T.dy, T.dw, T.dh);
      vctx.restore();

      const boxScale = clamp(+boxScaleEl.value, 0.35, 1.20);

      if (linksEl.checked && renderTracks.length >= 2){
        const screenBoxes = renderTracks.map(tr => mapVideoBoxToScreen(tr.bbox, T));
        const scaledBoxes = screenBoxes.map(b => scaleBox(b, boxScale));
        const pts = scaledBoxes.map(b => center(b));
        const links = makeLinks(pts, 2);
        const tt = performance.now()*0.001;

        for (const [i,j,dd] of links){
          const A = renderTracks[i], B = renderTracks[j];
          const a = pts[i], b = pts[j];
          const dist = Math.sqrt(dd);
          const norm = Math.min(1, dist / Math.max(W, H));

          const style = getLinkStyle(A.label, B.label, tt);
          const baseAlpha = (0.70*(1-norm) + 0.10) * style.alphaMul;
          const alpha = clamp(baseAlpha, 0.05, 0.95);

          vctx.save();
          if (style.dash) vctx.setLineDash(style.dash);
          else vctx.setLineDash([]);

          const jx = style.jitter ? (Math.sin((i+1)*13.1 + tt*4.0) * style.jitter) : 0;
          const jy = style.jitter ? (Math.cos((j+1)*9.7  + tt*3.4) * style.jitter) : 0;

          const baseW = Math.max(1.2, W/1100) * style.widthMul;

          vctx.strokeStyle = `rgba(255,255,255,${alpha.toFixed(3)})`;
          vctx.lineWidth = baseW;

          vctx.beginPath();
          vctx.moveTo(a.x + jx, a.y + jy);
          vctx.lineTo(b.x - jx, b.y - jy);
          vctx.stroke();

          if (style.glow > 0){
            const glowA = clamp(alpha + (0.12 + 0.18*Math.sin(tt*6.0 + i))*style.glow, 0.08, 0.95);
            vctx.setLineDash([]);
            vctx.strokeStyle = `rgba(255,255,255,${glowA.toFixed(3)})`;
            vctx.lineWidth = baseW * 1.6;
            vctx.beginPath();
            vctx.moveTo(a.x - jx*0.6, a.y - jy*0.6);
            vctx.lineTo(b.x + jx*0.6, b.y + jy*0.6);
            vctx.stroke();
          }

          vctx.restore();
        }
      }

      vctx.lineWidth = Math.max(2, W/900);

      for (let idx=0; idx<renderTracks.length; idx++){
        const tr = renderTracks[idx];
        const label = tr.label || "—";
        const col = LABEL_COLOR[label] || [255,255,255];

        const screenBox = mapVideoBoxToScreen(tr.bbox, T);
        const b = scaleBox(screenBox, boxScale);
        const [x,y,w,h] = b;

        if (fillFragEl.checked){
          const asset = assets.get(label);
          drawFragmentIntoBox(asset, b, (tr.seed + idx*77) >>> 0);
        }

        vctx.strokeStyle = `rgba(${col[0]},${col[1]},${col[2]},0.98)`;
        vctx.strokeRect(x,y,w,h);

        drawLabelTag(label, tr.cls, x, y);

        vctx.fillStyle = "rgba(255,255,255,0.9)";
        vctx.beginPath();
        vctx.arc(x+w/2, y+h/2, Math.max(2, W/750), 0, Math.PI*2);
        vctx.fill();
      }

      countEl.textContent = "Boxes " + renderTracks.length;
    }
  }

  let lastT = performance.now();
  let emaFps = 0;

  async function tick(){
    if(!runningDetect) return;

    const now = performance.now();
    if ((now - lastDetectAt) > DETECT_INTERVAL_MS){
      lastDetectAt = now;
      try{ await stepDetect(); }
      catch(e){ log("DETECT ERROR: " + (e?.message || e)); }
    }

    const dt = (now - lastT) / 1000;
    lastT = now;
    const inst = dt>0 ? (1/dt) : 0;
    emaFps = emaFps ? (emaFps*0.9 + inst*0.1) : inst;
    fpsEl.textContent = "FPS " + emaFps.toFixed(1);

    requestAnimationFrame(tick);
  }

  function renderLoop(){
    if(view.classList.contains("show")){
      drawCameraAndDetect();
    }
    requestAnimationFrame(renderLoop);
  }
  requestAnimationFrame(renderLoop);

  /* CAPTURE */
  let capturing=false;
  async function captureCurrentView(){
    if(capturing) return;
    capturing = true;
    try{
      setSleepPhotoStatus('Capturing...');
      const w = view.width;
      const h = view.height;

      freezeLayer.width = w;
      freezeLayer.height = h;

      const ctx = freezeLayer.getContext('2d');
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,w,h);
      ctx.drawImage(view, 0,0, w, h);

      await uploadSnapshotCanvas(freezeLayer);
    }catch(e){
      setSleepPhotoStatus('Capture error: ' + (e?.message || e));
      setTimeout(()=>setSleepPhotoStatus(''), 6000);
    }finally{
      freezeLayer.style.display = 'none';
      capturing = false;
    }
  }

  captureBtn.addEventListener('click', async (e)=>{
    e.preventDefault();
    await ensureResumed();
    playTap();
    captureCurrentView();
  }, {passive:false});

  /* UI 동작 */
  flipBtn.addEventListener('click', async ()=>{
    try{
      facingMode = (facingMode === "environment") ? "user" : "environment";
      if(!usingUploadVideo){
        await startCameraFresh();
        fadeInCamera(500);
      }
      log("flip: " + facingMode);
      playTap();
    }catch(e){
      log("flip error: " + (e?.message || e));
    }
  }, {passive:true});

  restartBtn.addEventListener('click', ()=>{
    objectTracks = [];
    renderTracks = [];
    lastDetectAt = 0;
    log("restart");
    playTap();
  }, {passive:true});

  useCamBtn.addEventListener('click', async ()=>{
    try{
      await startCameraFresh();
      fadeInCamera(500);
      objectTracks = [];
      renderTracks = [];
      log("source: camera");
      playTap();
    }catch(e){
      log("camera error: " + (e?.message || e));
    }
  }, {passive:true});

  videoFileEl.addEventListener('change', async ()=>{
    const file = videoFileEl.files?.[0];
    if(!file) return;
    try{
      await useUploadedVideo(file);
      fadeInCamera(500);
      objectTracks = [];
      renderTracks = [];
      log("uploaded: " + file.name);
      playTap();
    }catch(e){
      log("upload error: " + (e?.message || e));
    }
  }, {passive:true});

  /* =========================
     ✅ 스테이지 끝나면 본편 시작
     ========================= */
  async function endStageAndStartExperience(){
    // stage fade out
    stage.classList.add("hidden");
    await sleep(650);

    // 본편 UI 표시
    logEl.classList.add('show');
    controls.classList.add('show');
    captureBtn.classList.add('show');

    // view show
    view.classList.add("show");
    view.style.pointerEvents = "auto";

    try{
      await startCameraFresh();
      fadeInCamera(900);
    }catch(e){
      log("camera start failed: " + (e?.message || e));
    }

    try{
      statusEl.textContent = "Loading";
      await loadModel();
      await loadAssets();
      statusEl.textContent = "Camera";
    }catch(e){
      log("load error: " + (e?.message || e));
    }

    runningDetect = true;
    lastT = performance.now();
    lastDetectAt = 0;
    tick();
  }

})();
</script>
</body>
</html>
