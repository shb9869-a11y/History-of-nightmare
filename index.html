<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
<title>History of Nightmare — PWA Fix + Proscenium</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>
  :root{
    /* 뷰포트 치수: 브라우저 UI/홈바 영향 안받는 sv* 사용 */
    --vw: 100svw; --vh: 100svh;

    /* 프로시니엄(얇은 선) */
    --gap: 32px;                /* 가장자리 여백 */
    --line-color: rgba(255,255,255,.9);
    --line-w: 1px;
    --line-r: 2px;
  }
  @media (orientation:landscape){
    :root{ --gap: 24px; }
  }

  html,body{margin:0;height:100%;background:#000;overflow:hidden;-webkit-touch-callout:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}

  /* 카메라(흑백) 캔버스 */
  #view{
    position:fixed; left:0; top:0; width:var(--vw); height:var(--vh);
    display:block; z-index:0;
  }

  /* 레졸룸 오버레이(투명 배경 + 화면 꽉 채움, 터치 통과) */
  #ninjaOverlay{
    position:fixed; left:0; top:0; width:var(--vw); height:var(--vh);
    border:0; z-index:10; pointer-events:none;
    opacity:0; transition:opacity .35s ease;
    background:transparent;
  }

  /* 프로시니엄(얇은 테두리 선) — 안전영역 포함 */
  .proscenium{
    position:fixed;
    left:calc(var(--gap) + env(safe-area-inset-left));
    right:calc(var(--gap) + env(safe-area-inset-right));
    top:calc(var(--gap) + env(safe-area-inset-top));
    bottom:calc(var(--gap) + env(safe-area-inset-bottom));
    border:var(--line-w) solid var(--line-color);
    border-radius:var(--line-r);
    box-sizing:border-box;
    z-index:90;
    pointer-events:none;
    /* 픽셀 스냅으로 흐릿함 방지 */
    transform:translateZ(0);
  }

  /* IN/OUT 버튼 */
  .controls{
    position:fixed;
    right:calc(16px + env(safe-area-inset-right));
    bottom:calc(16px + env(safe-area-inset-bottom));
    z-index:100; display:flex; gap:8px
  }
  .uiBtn{
    background:#000;color:#fff;border:1px solid #333;
    font-family:"Courier New",monospace;padding:.6em 1.2em;cursor:pointer;user-select:none
  }

  /* 웰컴 오버레이 */
  #overlay{
    position:fixed; left:0; top:0; width:var(--vw); height:var(--vh);
    z-index:200; display:flex; align-items:center; justify-content:center;
    padding:20px; font-family:"Courier New",monospace; color:#fff; background:rgba(0,0,0,.7);
  }
  #overlayContent{line-height:1.7; text-align:center; transition:opacity .45s ease}
  .hidden{opacity:0}
  .warn{opacity:.8; font-size:12px; margin-top:8px}
</style>
</head>
<body>
  <!-- 관객 카메라(흑백) -->
  <canvas id="view"></canvas>

  <!-- 레졸룸(VDO.Ninja) 오버레이 (투명 배경) -->
  <iframe id="ninjaOverlay"
          allow="autoplay; fullscreen; camera; microphone; clipboard-read; clipboard-write"
          allowtransparency="true"
          style="background:transparent"
          referrerpolicy="no-referrer"
          src="about:blank"></iframe>

  <!-- 프로시니엄 선 -->
  <div class="proscenium" aria-hidden="true"></div>

  <!-- IN / OUT -->
  <div class="controls">
    <button class="uiBtn" id="btnIn">IN</button>
    <button class="uiBtn" id="btnOut">OUT</button>
  </div>

  <!-- 시작 오버레이 -->
  <div id="overlay">
    <div id="overlayContent">
      <button id="welcomeBtn" class="uiBtn">Welcome to History of Nightmare</button>
      <div id="httpsWarn" class="warn" style="display:none">HTTPS가 아니면 일부 권한이 제한될 수 있어요.</div>
      <div class="warn">버튼을 누르면 카메라/마이크/센서 권한을 요청합니다. iPhone은 <b>홈 화면 추가</b> 후에도 동작.</div>
    </div>
  </div>

<script>
(()=> {
/* ========== 설정 ========== */
const ROOM_ID = "YOURROOMID"; // ← 네 룸 아이디로 변경
/* VDO.Ninja 내부 배경/여백 제거 + 영상만 꽉 채우도록 CSS 주입 */
const injectedCss = encodeURIComponent(`
  html,body{background:transparent!important;margin:0!important;overflow:hidden!important;}
  #container,.container{background:transparent!important;}
  video,canvas{
    position:fixed!important; inset:0!important;
    width:100vw!important; height:100vh!important;
    object-fit:fill!important; background:transparent!important;
  }
`);
const base =
  \`https://vdo.ninja/?view=\${encodeURIComponent(ROOM_ID)}&clean&autostart&noaudio&codec=vp8&solo\` +
  \`&transparent=1&css=\${injectedCss}\`;
const ninjaUrl = () => \`\${base}&ts=\${Date.now()}\`; // 캐시 우회

/* ========== 요소 ========== */
const view = document.getElementById('view');
const vctx = view.getContext('2d',{alpha:false});
const ninja = document.getElementById('ninjaOverlay');
const btnIn = document.getElementById('btnIn');
const btnOut = document.getElementById('btnOut');
const overlayPanel = document.getElementById('overlay');
const overlayContent = document.getElementById('overlayContent');
const httpsWarn = document.getElementById('httpsWarn');

/* ========== 뷰포트 보정 (A2HS) ========== */
function setViewportVars(){
  // 일부 기기에서 svw/svh 지원이 미흡할 경우 대비
  document.documentElement.style.setProperty('--vw', window.innerWidth + 'px');
  document.documentElement.style.setProperty('--vh', window.innerHeight + 'px');
}
addEventListener('resize', ()=>{ setViewportVars(); setTimeout(fitCamera,50); });
setViewportVars();

/* ========== 카메라(흑백) ========== */
const cam = document.createElement('video'); cam.autoplay=true; cam.muted=true; cam.playsInline=true;
const proc = document.createElement('canvas'); const pctx = proc.getContext('2d',{willReadFrequently:true});
const PROC_SCALE=0.60;

function fitCamera(){
  const dpr = devicePixelRatio||1;
  view.width = innerWidth*dpr; view.height = innerHeight*dpr;
  vctx.setTransform(dpr,0,0,dpr,0,0);
  const scale = matchMedia('(orientation:landscape)').matches? PROC_SCALE*0.9 : PROC_SCALE;
  proc.width = Math.floor(innerWidth*scale);
  proc.height = Math.floor(innerHeight*scale);
}

async function startCamera(){
  // HTTPS가 아니면 getUserMedia가 거절될 수 있음 → 실패해도 전체 흐름을 막지 않음
  try{
    const s = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
    cam.srcObject=s; await cam.play().catch(()=>{});
  }catch(e){
    console.warn('Camera start failed (likely non-HTTPS):', e);
  }
}

let _loop=false;
function ensureLoop(){ if(_loop) return; _loop=true; loop(); }
function loop(){
  requestAnimationFrame(loop);
  const W=view.width/(devicePixelRatio||1), H=view.height/(devicePixelRatio||1);
  const PW=proc.width, PH=proc.height;
  pctx.clearRect(0,0,PW,PH);
  if (cam.readyState>=2){
    const vw=cam.videoWidth, vh=cam.videoHeight;
    if(vw&&vh){
      const sc=Math.max(PW/vw, PH/vh); // 비율 유지
      const dw=vw*sc, dh=vh*sc, dx=(PW-dw)/2, dy=(PH-dh)/2;
      pctx.drawImage(cam,dx,dy,dw,dh);
      const img=pctx.getImageData(0,0,PW,PH), d=img.data;
      for(let i=0;i<d.length;i+=4){ const g=(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2])|0; d[i]=d[i+1]=d[i+2]=g; }
      pctx.putImageData(img,0,0);
    }
  }
  vctx.clearRect(0,0,W,H);
  vctx.drawImage(proc,0,0,W,H);
}

/* ========== 오디오/센서 (마이크 + 기울기→팬/볼륨) ========== */
let audioCtx=null, mixBus=null, motionGain=null, masterGain=null, panSetter=null, micStream=null;
const VOL_BASE=0.20, VOL_MAX_ADD=0.55;
const SMOOTH_TC=0.08, CTRL_SMOOTH_ALPHA=0.12;
const DEADZONE_VOL_DEG=5, DEADZONE_PAN_DEG=3, VOL_TILT_LIMIT=60, PAN_LIMIT_DEG=45;

function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  mixBus = audioCtx.createGain();
  let panOut = null;
  if(audioCtx.createStereoPanner){
    const sp = audioCtx.createStereoPanner();
    panSetter = v=>{ try{ sp.pan.setTargetAtTime(v,audioCtx.currentTime,0.08);}catch{ sp.pan.value=v; } };
    mixBus.connect(sp); panOut = sp;
  }else{
    const l=audioCtx.createGain(), r=audioCtx.createGain(), m=audioCtx.createChannelMerger(2);
    mixBus.connect(l); mixBus.connect(r); l.connect(m,0,0); r.connect(m,0,1); panOut=m;
    panSetter = p=>{ const x=Math.max(-1,Math.min(1,p||0)), th=(x+1)*0.25*Math.PI; l.gain.value=Math.cos(th); r.gain.value=Math.sin(th); };
  }
  motionGain = audioCtx.createGain(); motionGain.gain.value=VOL_BASE;
  masterGain = audioCtx.createGain(); masterGain.gain.value=1.0;
  panOut.connect(motionGain); motionGain.connect(masterGain); masterGain.connect(audioCtx.destination);
}

async function startMic(){
  try{
    if(micStream) return;
    const s=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:false,noiseSuppression:true,autoGainControl:false},video:false});
    micStream=s; const src=audioCtx.createMediaStreamSource(s);
    const hpf=audioCtx.createBiquadFilter(); hpf.type='highpass'; hpf.frequency.value=220;
    const notch=audioCtx.createBiquadFilter(); notch.type='notch'; notch.frequency.value=300; notch.Q.value=3.5;
    const comp=audioCtx.createDynamicsCompressor(); comp.threshold.value=-20; comp.ratio.value=3.5; comp.attack.value=0.006; comp.release.value=0.12;
    const wet=audioCtx.createGain(); wet.gain.value=0.55; const dry=audioCtx.createGain(); dry.gain.value=0.08;
    const convolver=audioCtx.createConvolver(); convolver.buffer=makeIR(2.6,2.4);
    src.connect(hpf).connect(notch).connect(comp);
    const split=audioCtx.createGain(); comp.connect(split);
    split.connect(dry); split.connect(convolver).connect(wet);
    const bus=audioCtx.createGain(); dry.connect(bus); wet.connect(bus);
    bus.connect(mixBus);
  }catch(e){
    console.warn('Mic start failed (likely non-HTTPS):', e);
  }
}
function makeIR(sec=2.6,decay=2.4){
  const rate=audioCtx.sampleRate,len=Math.floor(rate*sec),ir=audioCtx.createBuffer(2,len,rate);
  for(let c=0;c<2;c++){ const v=ir.getChannelData(c); for(let i=0;i<len;i++){ const t=i/len, env=Math.pow(1-t,decay); v[i]=(Math.random()*2-1)*env*0.55; } }
  return ir;
}
let sensorsReady=false, latestOri={beta:0,gamma:0}, smVol=VOL_BASE, smPan=0;
async function sensorPerm(){
  try{ if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){ const r=await DeviceOrientationEvent.requestPermission(); if(r==='granted') sensorsReady=true; } else sensorsReady=true; }catch{}
  try{ if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){ const r=await DeviceMotionEvent.requestPermission(); if(r==='granted') sensorsReady=true; } }catch{}
}
function initOrientation(){ addEventListener('deviceorientation',e=>{ latestOri.beta=e.beta??0; latestOri.gamma=e.gamma??0; },{passive:true}); }
function smooth(t,c,a=CTRL_SMOOTH_ALPHA){ return c+(t-c)*a; }
function ctlLoop(){
  requestAnimationFrame(ctlLoop);
  let pan=0, vol=VOL_BASE;
  if(sensorsReady){
    const ang=(screen.orientation?.angle)||0, beta=latestOri.beta||0, gamma=latestOri.gamma||0;
    const panTilt=(ang%180===0)? gamma : beta;
    const volTilt=(ang%180===0)? beta  : -gamma;
    pan = Math.max(-1,Math.min(1,(Math.abs(panTilt)<DEADZONE_PAN_DEG?0:panTilt/PAN_LIMIT_DEG)));
    const a = Math.max(0,(Math.abs(volTilt)-DEADZONE_VOL_DEG)/(VOL_TILT_LIMIT-DEADZONE_VOL_DEG));
    vol = VOL_BASE + VOL_MAX_ADD*a;
  }
  smPan=smooth(pan,smPan); smVol=smooth(vol,smVol);
  if(panSetter) panSetter(smPan);
  if(motionGain){ const now=audioCtx.currentTime; try{ motionGain.gain.setTargetAtTime(smVol,now,SMOOTH_TC);}catch{ motionGain.gain.value=smVol; } }
}

/* ========== 레졸룸 오버레이: 프리로드 + IN/OUT ========== */
(function preloadOverlay(){
  ninja.src = ninjaUrl(); // 투명 배경/여백 제거된 페이지
})();
function setOverlay(on){
  ninja.style.opacity = on ? '0.5' : '0';  // 50% 블렌드
  if (on && !ninja.contentWindow) ninja.src = ninjaUrl();
}
btnIn.addEventListener('click', ()=> setOverlay(true));
btnOut.addEventListener('click', ()=> setOverlay(false));

/* ========== 웰컴 버튼(권한/초기화) ========== */
document.getElementById('welcomeBtn').addEventListener('click', async ()=>{
  // HTTPS 아니어도 흐름을 막지 않음 (경고만 표시)
  httpsWarn.style.display = window.isSecureContext ? 'none' : 'block';
  try{
    // iOS: 사용자 제스처 콜스택에서 모두 시작
    initAudio(); if(audioCtx.state==='suspended'){ await audioCtx.resume().catch(()=>{}); }
    await sensorPerm().catch(()=>{});
    await startMic().catch(()=>{});
    initOrientation(); ctlLoop();

    await startCamera(); fitCamera(); ensureLoop();

    overlayContent.classList.add('hidden'); setTimeout(()=>{ overlayPanel.style.display='none'; }, 450);
    setOverlay(true);
  }catch(e){
    overlayContent.innerHTML = '<div style="background:#000;padding:10px;display:inline-block">권한 허용이 필요합니다. (설정 > Safari 권한 확인)</div>';
  }
});

/* 오디오/센서 keep-alive (앱 재포커스 시) */
document.addEventListener('visibilitychange', ()=>{
  if(document.visibilityState === 'visible'){
    if(audioCtx && audioCtx.state==='suspended'){ audioCtx.resume().catch(()=>{}); }
  }
});

})();
</script>
</body>
</html>
