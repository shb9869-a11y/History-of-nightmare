<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,interactive-widget=resizes-content">
<title>From Emptiness (空) to Togetherness (共)</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="LIMEN">
<meta name="theme-color" content="#000000">

<!-- ✅ BOX DETECT libs -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>

<style>
:root{
  --frame: clamp(16px, 4vmin, 40px);
  --ui-gap: 8px;
  --fs-strong: clamp(14px, 2.8vmin, 18px);
  --fs-small: clamp(11px, 1.8vmin, 13px);
  --pad-btn-y: clamp(8px, 1.1vmin, 12px);
  --pad-btn-x: clamp(12px, 1.8vmin, 20px);
  --safe-t: env(safe-area-inset-top, 0px);
  --safe-b: env(safe-area-inset-bottom, 0px);
  --safe-l: env(safe-area-inset-left, 0px);
  --safe-r: env(safe-area-inset-right, 0px);

  /* ✅ palette */
  --ink: #0a0a0a;
  --paper: #e7e2c9;
  --paper-dim: rgba(231,226,201,.72);
  --line: rgba(231,226,201,.62);
  --line-2: rgba(231,226,201,.26);
  --accent-red: rgba(180,60,50,.75);

  --fade: 2500ms; /* ✅ 요청: 2.5초 */
}

html,body{
  margin:0; padding:0; width:100%; height:100%;
  background:#000; overflow:hidden;
  touch-action:manipulation;
}
body{
  font-family: ui-serif, "Iowan Old Style", "Palatino Linotype", Palatino,
               "Times New Roman", Times, serif;
  -webkit-user-select:none; user-select:none;
  -webkit-touch-callout:none;
  color:var(--paper);
}
*{
  box-sizing:border-box;
  -webkit-user-select:none; user-select:none;
  -webkit-touch-callout:none;
  -webkit-tap-highlight-color: transparent;
}

#bg{
  position:fixed; inset:0;
  width:100vw; height:100vh;
  display:block;
  z-index:0;
  background:#000;
}

#view{
  position:fixed; inset:0;
  width:100vw; height:100vh;
  display:block; z-index:2;
  filter:grayscale(1);
}

#freezeLayer{
  position:fixed; inset:0;
  z-index:500;
  display:none;
}

/* frame */
.frameBox{
  position:fixed;
  left:calc(var(--frame) + var(--safe-l));
  top:calc(var(--frame) + var(--safe-t));
  right:calc(var(--frame) + var(--safe-r));
  bottom:calc(var(--frame) + var(--safe-b));
  border:1.5px solid rgba(231,226,201,.68);
  pointer-events:none;
  z-index:50;
}

/* capture / status */
.uiBtn{
  background:transparent;
  color:var(--paper);
  border:none;
  font-size:var(--fs-strong);
  padding:var(--pad-btn-y) var(--pad-btn-x);
  font-family: inherit;
  letter-spacing: .10em;
  white-space:nowrap;
  cursor:pointer;
  opacity:.92;
}
.uiBtn.small{
  font-size:var(--fs-small);
  padding:calc(var(--pad-btn-y)*0.75) calc(var(--pad-btn-x)*0.75);
}
.uiBtn:active{opacity:.75; transform:translateY(1px);}
.uiBtn[disabled]{ opacity:.35; pointer-events:none; filter:grayscale(1); }

.controls{
  position:fixed;
  right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
  bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
  z-index:400;
  display:flex;
  gap:6px;
  align-items:center;
  opacity:0;
  transition:opacity var(--fade) ease;
}
.controls.show{opacity:1}
.readout{
  min-width:64px;
  text-align:center;
  opacity:.85;
  font-size:var(--fs-small);
  color:var(--paper);
  font-family: inherit;
}

.btn-capture{
  position:fixed;
  left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
  bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
  z-index:450;
  opacity:0;
  transition:opacity var(--fade) ease;
}
.btn-capture.show{opacity:1}

.sleep-status-text{
  position:fixed;
  left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
  bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b) + 34px);
  z-index:451;
  font-size:var(--fs-small);
  color:var(--paper-dim);
  text-shadow:0 0 6px rgba(0,0,0,0.7);
  max-width:min(76vw, 720px);
  letter-spacing:.08em;
}

/* =========================
   ✅ Overlays
   ========================= */
#overlayStack{
  position:fixed; inset:0;
  z-index:300;
  display:block;
  pointer-events:auto;
  background:#000;
}

.scene{
  position:absolute; inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:0;
  background:#000;
}
.scene.hidden{display:none;}

#scenePerm{
  cursor:pointer;
}
#matrix{
  position:absolute; inset:0;
  width:100%; height:100%;
  display:block;
}

/* scene 2: typing only */
#sceneTitle{
  cursor:pointer;
}
#typeLineWrap{
  position:absolute;
  left:calc(var(--frame) + var(--safe-l));
  right:calc(var(--frame) + var(--safe-r));
  bottom:calc(var(--frame) + var(--safe-b));
  padding:0;
  z-index:10;
  pointer-events:none;
}
#typeLine{
  font-family: ui-serif, "Iowan Old Style", "Palatino Linotype", Palatino, "Times New Roman", Times, serif;
  font-size:clamp(15px, 2.8vmin, 22px);
  letter-spacing:.08em;
  color:rgba(231,226,201,.92);
  text-shadow:0 0 14px rgba(0,0,0,.75);
  min-height:1.4em;
  white-space:pre-wrap;
}

/* fade helper */
.overlayFadeOut{
  opacity:0;
  transition:opacity var(--fade) ease;
}

/* =========================
   ✅ BOX DETECT UI - right vertical panel
   ========================= */
#toggleUI{
  position:fixed;
  right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
  top:calc(var(--frame) + var(--ui-gap) + var(--safe-t));
  z-index:920;
  background:transparent;
  border:none;
  padding:0;
  color:var(--paper);
  letter-spacing:.16em;
  font-family: inherit;
  opacity:.85;
  cursor:pointer;
}
#toggleUI:active{opacity:.62; transform:translateY(1px);}

#ui{
  position:fixed;
  right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
  top:calc(var(--frame) + var(--ui-gap) + var(--safe-t) + 34px);
  z-index:910;

  width:min(300px, calc(100vw - (var(--frame)*2) - 24px));
  max-height:calc(100vh - (var(--frame)*2) - 120px);
  overflow:auto;

  background:rgba(0,0,0,.38);
  border:1px solid rgba(231,226,201,.12);
  border-radius:18px;
  padding:12px;
  backdrop-filter: blur(10px);

  display:flex;
  flex-direction:column;
  gap:10px;
  pointer-events:auto;
  transition:.2s;

  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}
#ui.hidden{opacity:0; pointer-events:none; transform:translateY(-10px);}

.pill{
  display:grid;
  grid-template-columns: 92px 1fr auto;
  gap:10px;
  align-items:center;
  background:rgba(255,255,255,.045);
  border:1px solid rgba(231,226,201,.10);
  border-radius:16px;
  padding:10px 12px;
  color:#ddd;
}
.pill b{color:#fff; font-weight:800; letter-spacing:.12em;}
.pill input[type=range]{width:100%;}
.pill label{
  grid-column: 1 / -1;
  display:flex;
  align-items:center;
  gap:10px;
}
#ui button{
  appearance:none;
  border:1px solid rgba(231,226,201,.14);
  background:rgba(255,255,255,.06);
  color:#fff;
  padding:10px 12px;
  border-radius:14px;
  font-weight:800;
  pointer-events:auto;
}
#ui button:active{transform:translateY(1px);}

/* ✅ 시스템 상태: 좌측 상단 작게(항상) */
#log{
  position:fixed;
  left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
  top:calc(var(--frame) + var(--ui-gap) + var(--safe-t));
  z-index:905;
  font-size:10px;
  background:rgba(0,0,0,.12);
  border:1px solid rgba(231,226,201,.08);
  border-radius:12px;
  padding:6px 10px;
  backdrop-filter: blur(10px);
  max-width:min(86vw,820px);
  white-space:pre-wrap;
  pointer-events:none;
  color:rgba(231,226,201,.60);
  opacity:.35;
  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}
</style>
</head>

<body>
  <!-- dreamy background -->
  <canvas id="bg"></canvas>

  <!-- main output -->
  <canvas id="view"></canvas>
  <canvas id="freezeLayer"></canvas>

  <div class="frameBox" aria-hidden="true"></div>

  <div class="controls" id="controls">
    <button class="uiBtn small" id="zoomOut">–</button>
    <div class="readout"><span id="zoomVal">1.0×</span></div>
    <button class="uiBtn small" id="zoomIn">+</button>
  </div>

  <button id="captureBtn" class="uiBtn small btn-capture">Capture</button>
  <div id="sleepPhotoStatus" class="sleep-status-text"></div>

  <!-- ✅ BOX DETECT UI -->
  <button id="toggleUI">MENU</button>
  <div id="ui" class="hidden">
    <div class="pill">
      <b>COARSE</b>
      <input id="conf" type="range" min="0.01" max="0.95" step="0.01" value="0.12">
      <span id="confVal">0.12</span>
    </div>

    <div class="pill">
      <b>FINE</b>
      <input id="fine" type="range" min="0.00" max="1.00" step="0.01" value="0.40">
      <span id="fineVal">0.40</span>
    </div>

    <div class="pill">
      <b>N</b>
      <input id="topN" type="range" min="3" max="8" step="1" value="4">
      <span id="topNVal">4</span>
    </div>

    <div class="pill">
      <b>HOLD</b>
      <input id="holdSec" type="range" min="1" max="10" step="0.5" value="3.0">
      <span id="holdVal">3.0s</span>
    </div>

    <div class="pill">
      <b>BOX</b>
      <input id="boxScale" type="range" min="0.35" max="1.20" step="0.01" value="0.40">
      <span id="boxScaleVal">0.40</span>
    </div>

    <div class="pill">
      <label><input id="links" type="checkbox" checked> Links</label>
      <label><input id="fillFrag" type="checkbox" checked> Fragments</label>
    </div>

    <div class="pill" style="grid-template-columns: 1fr 1fr; gap:10px;">
      <button id="flip">Flip</button>
      <button id="restart">Restart</button>
    </div>

    <div class="pill" style="grid-template-columns: 92px 1fr; gap:10px;">
      <b>Source</b>
      <div style="display:flex; gap:10px; align-items:center; justify-content:flex-end;">
        <label style="display:flex; align-items:center; gap:8px;">
          <input id="videoFile" type="file" accept="video/*" style="max-width:160px;">
          <span style="opacity:.9">Upload</span>
        </label>
        <button id="useCam">Camera</button>
      </div>
    </div>

    <div class="pill" style="grid-template-columns: 1fr; gap:6px;">
      <span id="status"> </span>
      <span id="fps"> </span>
      <span id="count"> </span>
    </div>
  </div>

  <div id="log"> </div>

  <!-- ✅ overlay stack -->
  <div id="overlayStack">
    <!-- scene 1: matrix only -->
    <div id="scenePerm" class="scene">
      <canvas id="matrix"></canvas>
    </div>

    <!-- scene 2: typing line only -->
    <div id="sceneTitle" class="scene hidden">
      <div id="typeLineWrap">
        <div id="typeLine"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  /* =========================
     ✅ 업로드 서버 설정
     ========================= */
  const SLEEP_UPLOAD_SERVER = 'https://172.16.14.60:4443';
  const UPLOAD_TIMEOUT_MS = 12000;
  const UPLOAD_RETRY = 1;

  const FADE_MS = 2500; // ✅ 요청: 2.5초
  const TYPE_LINE = "탭하면 카메라가 시작되고, 박스가 화면에 떠오릅니다."; // ✅ 여기만 문구 바꾸면 됨
  const TYPE_SPEED_MS = 48; // 타이핑 속도

  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const qs = s => document.querySelector(s);
  const lerp=(a,b,t)=>a+(b-a)*t;
  const lerpBox=(cur,target,t)=>[lerp(cur[0],target[0],t),lerp(cur[1],target[1],t),lerp(cur[2],target[2],t),lerp(cur[3],target[3],t)];

  document.addEventListener('contextmenu', e=>e.preventDefault());
  document.addEventListener('selectstart', e=>e.preventDefault());

  /* =========================
     subtle click sfx
     ========================= */
  let audioCtx = null;
  function ensureAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  async function ensureResumed(){
    ensureAudio();
    if(audioCtx.state === 'suspended'){
      try{ await audioCtx.resume(); }catch(e){}
    }
  }
  const MASTER_SFX_GAIN = 0.18;
  async function playClick(){
    try{
      await ensureResumed();
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type='sine';
      o.frequency.setValueAtTime(190, now);
      o.frequency.exponentialRampToValueAtTime(140, now+0.12);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(MASTER_SFX_GAIN, now+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now+0.18);
      o.connect(g).connect(audioCtx.destination);
      o.start(now);
      o.stop(now+0.2);
    }catch(e){}
  }

  /* =========================
     DOM
     ========================= */
  const scenePerm = qs('#scenePerm');
  const sceneTitle = qs('#sceneTitle');
  const overlayStack = qs('#overlayStack');

  const typeLineEl = qs('#typeLine');

  const controls = qs('#controls');
  const zoomIn = qs('#zoomIn');
  const zoomOut = qs('#zoomOut');
  const zoomVal = qs('#zoomVal');
  const captureBtn = qs('#captureBtn');

  const bg = qs('#bg');
  const view = qs('#view');
  const freezeLayer = qs('#freezeLayer');

  const sleepPhotoStatus = qs('#sleepPhotoStatus');
  function setSleepPhotoStatus(msg){ sleepPhotoStatus.textContent = msg || ''; }

  const toggleUIBtn = qs('#toggleUI');
  const ui = qs('#ui');
  const logEl = qs('#log');

  const confEl = qs('#conf');
  const confVal = qs('#confVal');
  const fineEl = qs('#fine');
  const fineVal = qs('#fineVal');
  const topNEl = qs('#topN');
  const topNVal = qs('#topNVal');
  const holdSecEl = qs('#holdSec');
  const holdValEl = qs('#holdVal');
  const boxScaleEl = qs('#boxScale');
  const boxScaleValEl = qs('#boxScaleVal');

  const linksEl = qs('#links');
  const fillFragEl = qs('#fillFrag');

  const flipBtn = qs('#flip');
  const restartBtn = qs('#restart');
  const useCamBtn = qs('#useCam');
  const videoFileEl = qs('#videoFile');

  const statusEl = qs('#status');
  const fpsEl = qs('#fps');
  const countEl = qs('#count');

  function log(msg){
    logEl.textContent = String(msg ?? '');
  }

  /* =========================
     ✅ MENU
     ========================= */
  toggleUIBtn.addEventListener('click', ()=>{
    const hidden = ui.classList.toggle('hidden');
    toggleUIBtn.textContent = hidden ? 'MENU' : 'CLOSE';
    playClick();
  }, {passive:true});

  /* =========================
     ✅ Background: points & lines (dream)
     ========================= */
  const bctx = bg.getContext('2d', { alpha:false });

  const bgState = { pts: [], t0: performance.now(), swirl: 0, pulse: 0 };

  function resizeCanvas(c){
    const dpr = window.devicePixelRatio || 1;
    const w = innerWidth, h = innerHeight;
    c.width = Math.round(w * dpr);
    c.height = Math.round(h * dpr);
    const ctx = c.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  function resizeAll(){
    resizeCanvas(bg);
    const dpr=window.devicePixelRatio||1;
    const w=window.innerWidth;
    const h=window.innerHeight;
    view.width=w*dpr;
    view.height=h*dpr;
    const vctx = view.getContext('2d', { alpha:false });
    vctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resizeAll, {passive:true});
  window.addEventListener('orientationchange', resizeAll, {passive:true});
  resizeAll();

  function initBgPoints(){
    const W = innerWidth, H = innerHeight;
    const n = Math.round(clamp((W*H)/11000, 60, 140));
    bgState.pts = [];
    for(let i=0;i<n;i++){
      bgState.pts.push({
        x: Math.random()*W,
        y: Math.random()*H,
        vx: (Math.random()-0.5)*0.20,
        vy: (Math.random()-0.5)*0.20,
        r: 0.6 + Math.random()*1.4,
        k: Math.random()*6.28
      });
    }
  }
  initBgPoints();

  function bgLoop(){
    const W = innerWidth, H = innerHeight;
    const t = (performance.now() - bgState.t0) * 0.001;

    bgState.pulse = 0.5 + 0.5*Math.sin(t*0.65);
    bgState.swirl = 0.35*Math.sin(t*0.23);

    bctx.fillStyle = '#000';
    bctx.fillRect(0,0,W,H);

    const cx = W*0.52, cy = H*0.46;
    for(const p of bgState.pts){
      const dx = p.x - cx, dy = p.y - cy;
      const ang = Math.atan2(dy, dx) + bgState.swirl*0.35;
      const pull = 0.0006 * (0.6 + bgState.pulse);

      p.vx += -Math.cos(ang+Math.PI/2) * pull * (Math.abs(dx)+120);
      p.vy += -Math.sin(ang+Math.PI/2) * pull * (Math.abs(dy)+120);

      p.vx += 0.03*Math.sin(t*0.9 + p.k) * 0.02;
      p.vy += 0.03*Math.cos(t*0.8 + p.k) * 0.02;

      p.vx *= 0.985;
      p.vy *= 0.985;

      p.x += p.vx;
      p.y += p.vy;

      if(p.x < -20) p.x = W+20;
      if(p.x > W+20) p.x = -20;
      if(p.y < -20) p.y = H+20;
      if(p.y > H+20) p.y = -20;
    }

    const maxDist = Math.min(W,H) * (0.18 + 0.07*bgState.pulse);
    const maxD2 = maxDist*maxDist;

    bctx.save();
    bctx.globalCompositeOperation = 'lighter';

    for(let i=0;i<bgState.pts.length;i++){
      const a = bgState.pts[i];
      for(let j=i+1;j<bgState.pts.length;j++){
        const b = bgState.pts[j];
        const dx = a.x-b.x, dy = a.y-b.y;
        const d2 = dx*dx+dy*dy;
        if(d2 > maxD2) continue;

        const d = Math.sqrt(d2);
        const alpha = clamp(1 - (d/maxDist), 0, 1);
        const w = 0.6 + alpha*0.9;

        bctx.lineWidth = w;
        bctx.strokeStyle = `rgba(231,226,201,${(0.05 + 0.18*alpha).toFixed(3)})`;
        bctx.beginPath();
        bctx.moveTo(a.x, a.y);
        bctx.lineTo(b.x, b.y);
        bctx.stroke();
      }
    }

    for(const p of bgState.pts){
      const glow = 0.22 + 0.55*bgState.pulse;
      bctx.fillStyle = `rgba(231,226,201,${(0.18*glow).toFixed(3)})`;
      bctx.beginPath();
      bctx.arc(p.x, p.y, p.r*(0.9+0.35*bgState.pulse), 0, Math.PI*2);
      bctx.fill();
    }

    bctx.restore();
    requestAnimationFrame(bgLoop);
  }
  requestAnimationFrame(bgLoop);

  /* =========================
     ✅ Matrix 0/1 rain
     ========================= */
  const matrixCanvas = qs('#matrix');
  const mctx = matrixCanvas.getContext('2d', { alpha:false });

  const mState = {
    cols: [],
    fontSize: 16,
    dpr: window.devicePixelRatio || 1,
    last: performance.now()
  };

  function resizeMatrix(){
    const dpr = window.devicePixelRatio || 1;
    mState.dpr = dpr;
    matrixCanvas.width = Math.round(innerWidth * dpr);
    matrixCanvas.height = Math.round(innerHeight * dpr);
    mctx.setTransform(dpr,0,0,dpr,0,0);

    mState.fontSize = clamp(Math.round(innerWidth/52), 14, 22);
    const cols = Math.ceil(innerWidth / (mState.fontSize * 0.78));
    mState.cols = [];
    for(let i=0;i<cols;i++){
      mState.cols.push({
        x: i * (mState.fontSize * 0.78),
        y: Math.random() * innerHeight,
        v: 40 + Math.random()*140,
        phase: Math.random()*999
      });
    }
  }
  resizeMatrix();
  window.addEventListener('resize', resizeMatrix, {passive:true});
  window.addEventListener('orientationchange', resizeMatrix, {passive:true});

  function matrixLoop(){
    const W = innerWidth, H = innerHeight;
    const now = performance.now();
    const dt = (now - mState.last) / 1000;
    mState.last = now;

    // fade trail
    mctx.fillStyle = 'rgba(0,0,0,0.20)';
    mctx.fillRect(0,0,W,H);

    mctx.font = `${mState.fontSize}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace`;
    mctx.textBaseline = 'top';

    for(const c of mState.cols){
      c.y += c.v * dt;
      if(c.y > H + 40) c.y = -Math.random()*200;

      // draw a short vertical stack
      const stack = 10;
      for(let k=0;k<stack;k++){
        const yy = c.y - k*(mState.fontSize*1.15);
        if(yy < -40 || yy > H+40) continue;
        const bit = ((Math.sin((c.phase + yy*0.02) * 2.1) > 0) ? '1' : '0');

        // warm paper-ish matrix (not green), but still "matrix" feel
        const a = clamp(0.08 + (k===0 ? 0.35 : 0.18) - k*0.012, 0.03, 0.38);
        mctx.fillStyle = `rgba(231,226,201,${a.toFixed(3)})`;
        mctx.fillText(bit, c.x, yy);
      }
    }

    requestAnimationFrame(matrixLoop);
  }
  requestAnimationFrame(matrixLoop);

  /* =========================
     캔버스/카메라
     ========================= */
  const vctx = view.getContext('2d', { alpha:false });

  let camStream=null;
  let camVideo=null;
  let facingMode='environment';
  let usingUploadVideo=false;

  let ZOOM=1.0;
  let showCamera=false;
  let camFadeAlpha=0;

  function updateZoomLabel(){ zoomVal.textContent = ZOOM.toFixed(1)+'×'; }
  updateZoomLabel();

  zoomIn.addEventListener('click', async ()=>{
    await ensureResumed();
    ZOOM=Math.min(3.0, ZOOM+0.1);
    updateZoomLabel();
    playClick();
  }, {passive:true});

  zoomOut.addEventListener('click', async ()=>{
    await ensureResumed();
    ZOOM=Math.max(1.0, ZOOM-0.1);
    updateZoomLabel();
    playClick();
  }, {passive:true});

  async function startCameraFresh(){
    usingUploadVideo=false;
    if (camStream){
      camStream.getTracks().forEach(t=>t.stop());
      camStream=null;
    }
    const s = await navigator.mediaDevices.getUserMedia({
      video:{
        facingMode:{ideal:facingMode},
        width:{min:1280,ideal:1920},
        height:{min:720,ideal:1080},
        aspectRatio:{ideal:16/9}
      },
      audio:false
    });
    camStream = s;

    if(!camVideo){
      camVideo=document.createElement('video');
      camVideo.setAttribute('playsinline','');
      camVideo.autoplay=true;
      camVideo.playsInline=true;
      camVideo.muted=true;
    }
    camVideo.srcObject=camStream;
    camVideo.src = '';
    await camVideo.play().catch(()=>{});
    if (camVideo.readyState < 1){
      await new Promise(res=>camVideo.addEventListener('loadedmetadata', res, {once:true}));
    }
  }

  async function useUploadedVideo(file){
    usingUploadVideo=true;
    if (camStream){
      camStream.getTracks().forEach(t=>t.stop());
      camStream=null;
    }
    if(!camVideo){
      camVideo=document.createElement('video');
      camVideo.setAttribute('playsinline','');
      camVideo.autoplay=true;
      camVideo.playsInline=true;
      camVideo.muted=true;
    }
    camVideo.srcObject=null;
    camVideo.loop=true;
    camVideo.muted=true;
    camVideo.src = URL.createObjectURL(file);
    await camVideo.play().catch(()=>{});
    if (camVideo.readyState < 1){
      await new Promise(res=>camVideo.addEventListener('loadedmetadata', res, {once:true}));
    }
  }

  function fadeInCamera(dur=FADE_MS){
    showCamera = true;
    const start = performance.now();
    camFadeAlpha = 0;
    function step(){
      const t = (performance.now() - start) / dur;
      camFadeAlpha = clamp(t, 0, 1);
      if(t < 1 && showCamera) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  function getCameraDrawTransform(){
    const w = view.clientWidth || innerWidth;
    const h = view.clientHeight || innerHeight;

    if(!camVideo || camVideo.readyState < 2) return null;
    const vw = camVideo.videoWidth, vh = camVideo.videoHeight;
    if(!vw || !vh) return null;

    const fw = w, fh = h;
    const videoRatio = vw / vh;
    const frameRatio = fw / fh;

    let dw, dh;
    if(videoRatio > frameRatio){ dh = fh; dw = dh * videoRatio; }
    else { dw = fw; dh = dw / videoRatio; }

    dw *= ZOOM; dh *= ZOOM;
    const dx = (fw - dw)/2;
    const dy = (fh - dh)/2;

    return { vw, vh, dx, dy, dw, dh, fw, fh };
  }

  /* =========================
     ✅ 업로드
     ========================= */
  function humanErr(e){
    const msg = (e && e.message) ? e.message : String(e);
    if (/aborted/i.test(msg)) return "timeout";
    return msg;
  }

  async function canvasToJpegBlobResized(srcCanvas, maxLongSide=1600, quality=0.85){
    const w = srcCanvas.width;
    const h = srcCanvas.height;
    if (!w || !h) return null;

    const longSide = Math.max(w,h);
    const scale = Math.min(1, maxLongSide / longSide);

    const tw = Math.max(1, Math.round(w * scale));
    const th = Math.max(1, Math.round(h * scale));

    let target = srcCanvas;
    if (scale < 0.999){
      const c = document.createElement("canvas");
      c.width = tw;
      c.height = th;
      const cctx = c.getContext("2d");
      cctx.imageSmoothingEnabled = true;
      cctx.imageSmoothingQuality = "high";
      cctx.drawImage(srcCanvas, 0,0,w,h, 0,0,tw,th);
      target = c;
    }

    const blob = await new Promise((resolve) => {
      target.toBlob((b)=>resolve(b), "image/jpeg", quality);
    });

    return blob;
  }

  async function fetchWithTimeout(url, options={}, timeoutMs=UPLOAD_TIMEOUT_MS){
    const controller = new AbortController();
    const id = setTimeout(()=>controller.abort(new Error("aborted")), timeoutMs);
    try{
      const res = await fetch(url, { ...options, signal: controller.signal });
      return res;
    } finally {
      clearTimeout(id);
    }
  }

  async function uploadBlob(blob){
    const formData = new FormData();
    formData.append("image", blob, `sleep_capture_${Date.now()}.jpg`);
    const base = (SLEEP_UPLOAD_SERVER && SLEEP_UPLOAD_SERVER.trim()) ? SLEEP_UPLOAD_SERVER.trim() : '';
    const url = base + "/upload";

    let res = await fetchWithTimeout(url, { method:"POST", body: formData }, UPLOAD_TIMEOUT_MS);
    if ((!res.ok && res.status >= 500) && UPLOAD_RETRY > 0){
      await new Promise(r=>setTimeout(r, 400));
      res = await fetchWithTimeout(url, { method:"POST", body: formData }, UPLOAD_TIMEOUT_MS);
    }
    return res;
  }

  async function uploadSnapshotCanvas(canvas){
    try{
      setSleepPhotoStatus('Uploading...');
      const blob = await canvasToJpegBlobResized(canvas, 1600, 0.85);
      if(!blob){
        setSleepPhotoStatus('Upload error');
        return;
      }

      const res = await uploadBlob(blob);

      if(!res.ok){
        const txt = await res.text().catch(()=> "");
        setSleepPhotoStatus(`Upload failed: ${res.status}${txt ? " / " + txt.slice(0,80) : ""}`);
        return;
      }

      const ct = res.headers.get("content-type") || "";
      if (ct.includes("application/json")){
        await res.json().catch(()=>({}));
      } else {
        await res.text().catch(()=> "");
      }

      setSleepPhotoStatus('Uploaded');
      setTimeout(()=>setSleepPhotoStatus(''), 2600);
    }catch(err){
      console.error("UPLOAD ERROR RAW:", err);
      setSleepPhotoStatus('Upload error: ' + humanErr(err));
      setTimeout(()=>setSleepPhotoStatus(''), 5200);
    }
  }

  /* =========================
     ✅ BOX DETECT assets
     ========================= */
  const LIMEN_LABELS = ["Mom","Hometown","Son Duk-Geum","GrandFather","Ocean"];
  const CLASS_TO_LIMEN = {
    person: "Mom",
    diningtable: "Hometown",
    bottle: "Ocean",
    cup: "Hometown",
    fork: "Son Duk-Geum",
    knife: "Son Duk-Geum",
    spoon: "Son Duk-Geum",
    chair: "GrandFather",
    tv: "Ocean",
    laptop: "Ocean",
    "cell phone": "Ocean"
  };
  function pickLimenLabelByClass(cocoClass, fallbackIndex){
    return CLASS_TO_LIMEN[cocoClass] || LIMEN_LABELS[fallbackIndex % LIMEN_LABELS.length];
  }
  function shuffleCopy(arr){
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  const ASSET_FILES = {
    "Mom": "assets/mom.jpg",
    "Hometown": "assets/hometown.jpg",
    "Son Duk-Geum": "assets/son-duk-geum.jpg",
    "GrandFather": "assets/grandfather.jpg",
    "Ocean": "assets/ocean.jpg"
  };

  const assets = new Map();
  async function loadAssets(){
    assets.clear();
    const entries = Object.entries(ASSET_FILES);
    for (const [label, path] of entries){
      const img = new Image();
      img.crossOrigin = "anonymous";
      const rec = { el:img, ready:false, path };
      assets.set(label, rec);
      await new Promise((res) => {
        img.onload = () => { rec.ready = true; res(); };
        img.onerror = () => { rec.ready = false; res(); };
        img.src = path + "?v=" + Date.now();
      });
    }
  }

  /* =========================
     ✅ coco-ssd model
     ========================= */
  let model=null;
  async function loadModel(){
    if(model) return model;
    model = await cocoSsd.load({ base:"lite_mobilenet_v2" });
    return model;
  }

  function iou(a,b){
    const ax1=a[0], ay1=a[1], ax2=a[0]+a[2], ay2=a[1]+a[3];
    const bx1=b[0], by1=b[1], bx2=b[0]+b[2], by2=b[1]+b[3];
    const ix1=Math.max(ax1,bx1), iy1=Math.max(ay1,by1);
    const ix2=Math.min(ax2,bx2), iy2=Math.min(ay2,by2);
    const iw=Math.max(0, ix2-ix1), ih=Math.max(0, iy2-iy1);
    const inter=iw*ih;
    const ua=a[2]*a[3] + b[2]*b[3] - inter;
    return ua>0 ? inter/ua : 0;
  }
  function center(b){ return {x:b[0]+b[2]/2, y:b[1]+b[3]/2}; }
  function makeLinks(points, k=2){
    const links=[];
    for(let i=0;i<points.length;i++){
      const ds=[];
      for(let j=0;j<points.length;j++){
        if(i===j) continue;
        const dx=points[i].x-points[j].x, dy=points[i].y-points[j].y;
        ds.push({j, d:dx*dx+dy*dy});
      }
      ds.sort((a,b)=>a.d-b.d);
      for(let t=0;t<Math.min(k, ds.length);t++){
        const j=ds[t].j;
        if(i<j) links.push([i,j,ds[t].d]);
      }
    }
    return links;
  }
  function fract(x){ return x - Math.floor(x); }
  function scaleBox(bbox, s){
    const [x,y,w,h]=bbox;
    const cx = x + w/2, cy = y + h/2;
    const nw = w * s, nh = h * s;
    return [cx - nw/2, cy - nh/2, nw, nh];
  }

  function drawFragmentIntoBox(assetRec, bbox, seed, alphaMul=1){
    if (!assetRec || !assetRec.ready) return;
    const [x,y,w,h] = bbox;
    if (w < 8 || h < 8) return;

    const t = performance.now() * 0.001;
    const r1 = fract(Math.sin(seed*12.9898 + t*1.3) * 43758.5453);
    const r2 = fract(Math.sin(seed*78.233  + t*0.9) * 12345.6789);
    const r3 = fract(Math.sin(seed*41.77   + t*1.7) * 98765.4321);

    vctx.save();
    vctx.beginPath(); vctx.rect(x,y,w,h); vctx.clip();

    const scale = 1.05 + r1 * 1.25;
    const ox = (r2 - 0.5) * w * 0.35;
    const oy = (r3 - 0.5) * h * 0.35;

    const el = assetRec.el;
    const sw = el.naturalWidth||0;
    const sh = el.naturalHeight||0;
    if (sw < 2 || sh < 2){ vctx.restore(); return; }

    const dw = w * scale, dh = h * scale;
    const dx = x + (w - dw)/2 + ox;
    const dy = y + (h - dh)/2 + oy;

    vctx.globalAlpha = 0.85 * alphaMul;
    vctx.drawImage(el, dx, dy, dw, dh);

    vctx.globalAlpha = 0.32 * alphaMul;
    const dw2 = w * (0.85 + r2*0.5);
    const dh2 = h * (0.85 + r3*0.5);
    const dx2 = x + (w - dw2)/2 - ox*0.25;
    const dy2 = y + (h - dh2)/2 - oy*0.25;
    vctx.drawImage(el, dx2, dy2, dw2, dh2);

    vctx.restore();
    vctx.globalAlpha = 1;
  }

  function drawLabelTag(label, cocoClass, x, y, alphaMul=1){
    const text = `${label} · ${cocoClass}`;
    vctx.font = `${Math.max(12, Math.round((view.clientWidth||innerWidth)/95))}px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;
    vctx.textBaseline = "top";
    const padX = 7, padY = 4;
    const tw = vctx.measureText(text).width;
    const th = Math.max(18, Math.round((view.clientWidth||innerWidth)/75));

    const ty = Math.max(0, y - th - 2);
    vctx.fillStyle = `rgba(0,0,0,${(0.60*alphaMul).toFixed(3)})`;
    vctx.fillRect(x, ty, tw + padX*2, th);

    vctx.fillStyle = `rgba(231,226,201,${(0.95*alphaMul).toFixed(3)})`;
    vctx.fillText(text, x + padX, ty + padY);
  }

  function computeMinAreaFromFine(fine, vw, vh){
    const base = vw * vh;
    const minRatio = 0.0015;
    const maxRatio = 0.12;
    const r = minRatio + (1 - fine) * (maxRatio - minRatio);
    return base * r;
  }

  let objectTracks = [];
  let renderTracks = [];
  let nextId = 1;

  function ensureDistinctLabelsForTopN(objs, nowMs){
    const holdMs = (+holdSecEl.value) * 1000;

    for (const o of objs){
      if (!o.label || nowMs > o.labelUntil) o.label = null;
    }

    const used = new Set(objs.filter(o=>o.label).map(o=>o.label));
    for (let i=0;i<objs.length;i++){
      const o = objs[i];
      if (!o.label){
        let candidate = pickLimenLabelByClass(o.cls, i);
        if (used.has(candidate)){
          const pool = shuffleCopy(LIMEN_LABELS).filter(L=>!used.has(L));
          if (pool.length) candidate = pool[0];
        }
        o.label = candidate;
        o.labelUntil = nowMs + holdMs;
        used.add(candidate);
      }
    }
  }

  const DETECT_INTERVAL_MS = 240;
  let lastDetectAt = 0;
  let runningDetect = false;

  async function stepDetect(){
    if(!model) await loadModel();
    if(!camVideo || camVideo.readyState < 2) return;

    const coarse = +confEl.value;
    const fine = +fineEl.value;
    confVal.textContent = coarse.toFixed(2);
    fineVal.textContent = fine.toFixed(2);

    let wantN = +topNEl.value;
    wantN = clamp(wantN, 3, 8);
    topNVal.textContent = String(wantN);

    holdValEl.textContent = (+holdSecEl.value).toFixed(1) + "s";

    // ✅ boxScale 시작값 0.40 유지
    const bs = clamp(+boxScaleEl.value, 0.35, 1.20);
    boxScaleValEl.textContent = bs.toFixed(2);

    const vw = camVideo.videoWidth || 0;
    const vh = camVideo.videoHeight || 0;
    const minArea = computeMinAreaFromFine(fine, vw||1280, vh||720);

    let preds = await model.detect(camVideo);

    preds = preds
      .filter(p => (p.score >= coarse) && ((p.bbox[2]*p.bbox[3]) >= minArea))
      .sort((a,b) => b.score - a.score);

    const candidates = preds.slice(0, 12);
    const nowMs = performance.now();

    const used = new Set();
    for (const tr of objectTracks){
      let bestJ = -1, bestI = 0;
      for (let j=0;j<candidates.length;j++){
        if (used.has(j)) continue;
        const s = iou(tr.bbox, candidates[j].bbox);
        if (s > bestI){ bestI=s; bestJ=j; }
      }
      if (bestJ >= 0 && bestI > 0.18){
        const p = candidates[bestJ];
        used.add(bestJ);
        tr.bbox = lerpBox(tr.bbox, p.bbox, 0.55);
        tr.cls = p.class;
        tr.score = p.score;
        tr.lastSeen = nowMs;
      }
    }

    for (let j=0;j<candidates.length;j++){
      if (used.has(j)) continue;
      const p = candidates[j];
      objectTracks.push({
        id: nextId++,
        bbox: p.bbox.slice(),
        cls: p.class,
        score: p.score,
        label: null,
        labelUntil: 0,
        lastSeen: nowMs,
        seed: (nextId*971 + j*37) >>> 0
      });
    }

    objectTracks = objectTracks.filter(tr => (nowMs - tr.lastSeen) < 1200);
    objectTracks.sort((a,b)=>b.score-a.score);
    renderTracks = objectTracks.slice(0, wantN);
    ensureDistinctLabelsForTopN(renderTracks, nowMs);

    // ✅ 큰 안내 문구는 안 띄움(필요 시 log에만)
    if(usingUploadVideo){
      // no-op
    }
  }

  function mapVideoBoxToScreen(bbox, T){
    const [x,y,w,h] = bbox;
    const sx = T.dx + (x / T.vw) * T.dw;
    const sy = T.dy + (y / T.vh) * T.dh;
    const sw = (w / T.vw) * T.dw;
    const sh = (h / T.vh) * T.dh;
    return [sx, sy, sw, sh];
  }

  function drawCameraAndDetect(){
    const W = view.clientWidth || innerWidth;
    const H = view.clientHeight || innerHeight;

    vctx.save();
    vctx.fillStyle = '#000';
    vctx.fillRect(0,0,W,H);
    vctx.restore();

    const T = getCameraDrawTransform();
    if(showCamera && T){
      // camera
      vctx.save();
      vctx.globalAlpha = camFadeAlpha;
      vctx.drawImage(camVideo, T.dx, T.dy, T.dw, T.dh);
      vctx.restore();

      const alphaMul = camFadeAlpha; // ✅ 박스/라인/라벨도 같이 페이드인
      const boxScale = clamp(+boxScaleEl.value, 0.35, 1.20);

      if (linksEl.checked && renderTracks.length >= 2){
        const screenBoxes = renderTracks.map(tr => mapVideoBoxToScreen(tr.bbox, T));
        const scaledBoxes = screenBoxes.map(b => scaleBox(b, boxScale));
        const pts = scaledBoxes.map(b => center(b));
        const links = makeLinks(pts, 2);

        for (const [i,j,dd] of links){
          const a = pts[i], b = pts[j];
          const dist = Math.sqrt(dd);
          const norm = Math.min(1, dist / Math.max(W, H));
          const alpha = clamp((0.62*(1-norm) + 0.10), 0.05, 0.85) * alphaMul;

          vctx.save();
          vctx.setLineDash([]);
          vctx.strokeStyle = `rgba(231,226,201,${alpha.toFixed(3)})`;
          vctx.lineWidth = Math.max(1.1, W/1150);
          vctx.beginPath();
          vctx.moveTo(a.x, a.y);
          vctx.lineTo(b.x, b.y);
          vctx.stroke();
          vctx.restore();
        }
      }

      vctx.lineWidth = Math.max(2, W/980);

      for (let idx=0; idx<renderTracks.length; idx++){
        const tr = renderTracks[idx];
        const label = tr.label || "—";

        const screenBox = mapVideoBoxToScreen(tr.bbox, T);
        const b = scaleBox(screenBox, boxScale);
        const [x,y,w,h] = b;

        if (fillFragEl.checked){
          const asset = assets.get(label);
          drawFragmentIntoBox(asset, b, (tr.seed + idx*77) >>> 0, alphaMul);
        }

        vctx.save();
        vctx.globalAlpha = alphaMul;
        vctx.strokeStyle = `rgba(231,226,201,0.92)`;
        vctx.strokeRect(x,y,w,h);
        vctx.restore();

        drawLabelTag(label, tr.cls, x, y, alphaMul);
      }

      countEl.textContent = "Boxes " + renderTracks.length;
    }
  }

  let lastT = performance.now();
  let emaFps = 0;

  async function tick(){
    if(!runningDetect) return;

    const now = performance.now();
    if ((now - lastDetectAt) > DETECT_INTERVAL_MS){
      lastDetectAt = now;
      try{ await stepDetect(); }
      catch(e){ log("DETECT ERROR: " + (e?.message || e)); }
    }

    const dt = (now - lastT) / 1000;
    lastT = now;
    const inst = dt>0 ? (1/dt) : 0;
    emaFps = emaFps ? (emaFps*0.9 + inst*0.1) : inst;

    // ✅ log에만 아주 작게 상태 표시
    log(`FPS ${emaFps.toFixed(1)}   |   Boxes ${renderTracks.length}`);

    requestAnimationFrame(tick);
  }

  function renderLoop(){
    drawCameraAndDetect();
    requestAnimationFrame(renderLoop);
  }
  requestAnimationFrame(renderLoop);

  /* =========================
     CAPTURE → 업로드
     ========================= */
  let capturing=false;
  async function captureCurrentView(){
    if(capturing) return;
    capturing = true;
    try{
      setSleepPhotoStatus('Capturing...');
      const w = view.width;
      const h = view.height;

      freezeLayer.width = w;
      freezeLayer.height = h;

      const ctx = freezeLayer.getContext('2d');
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,w,h);
      ctx.drawImage(view, 0,0, w, h);

      await uploadSnapshotCanvas(freezeLayer);
    }catch(e){
      setSleepPhotoStatus('Capture error');
      setTimeout(()=>setSleepPhotoStatus(''), 5000);
    }finally{
      freezeLayer.style.display = 'none';
      capturing = false;
    }
  }

  captureBtn.addEventListener('click', async (e)=>{
    e.preventDefault();
    await ensureResumed();
    playClick();
    captureCurrentView();
  }, {passive:false});

  /* =========================
     UI 동작
     ========================= */
  flipBtn.addEventListener('click', async ()=>{
    try{
      facingMode = (facingMode === "environment") ? "user" : "environment";
      if(!usingUploadVideo){
        await startCameraFresh();
        fadeInCamera(FADE_MS);
      }
      playClick();
    }catch(e){
      log("flip error");
    }
  }, {passive:true});

  restartBtn.addEventListener('click', ()=>{
    objectTracks = [];
    renderTracks = [];
    lastDetectAt = 0;
    playClick();
  }, {passive:true});

  useCamBtn.addEventListener('click', async ()=>{
    try{
      await startCameraFresh();
      fadeInCamera(FADE_MS);
      objectTracks = [];
      renderTracks = [];
      playClick();
    }catch(e){
      log("camera error");
    }
  }, {passive:true});

  videoFileEl.addEventListener('change', async ()=>{
    const file = videoFileEl.files?.[0];
    if(!file) return;
    try{
      await useUploadedVideo(file);
      fadeInCamera(FADE_MS);
      objectTracks = [];
      renderTracks = [];
      playClick();
    }catch(e){
      log("upload error");
    }
  }, {passive:true});

  /* =========================
     ✅ New flow
     1) Scene1(매트릭스) 탭 → (권한요청+워밍업) + 오버레이 페이드아웃(2.5s) → Scene2로 전환
     2) Scene2(타이핑) 시작 → 아래 글자 타이핑
     3) Scene2 탭 → 오버레이 페이드아웃(2.5s) + 카메라/박스 페이드인(2.5s) + 디텍트 시작
     ========================= */
  let warmed = false;
  let typing = false;

  // ✅ 시작 박스 스케일 0.40 고정 스타트
  boxScaleEl.value = "0.40";
  boxScaleValEl.textContent = "0.40";

  async function warmUp(){
    if (warmed) return;
    warmed = true;
    try{
      // 조용히 로드(큰 안내 없음)
      await loadModel();
      await loadAssets();
    }catch(e){
      log("warmup error");
    }
  }

  async function requestCameraPermission(){
    try{
      const s = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:{ideal:facingMode} },
        audio:false
      });
      s.getTracks().forEach(t=>t.stop());
      return true;
    }catch(e){
      return false;
    }
  }

  function fadeToTitle(){
    // Scene1 -> Scene2 전환 자체는 즉시, 대신 overlayStack 자체를 2.5초로 한번 숨겼다가 다시 보이게
    overlayStack.classList.add('overlayFadeOut');
    setTimeout(()=>{
      scenePerm.classList.add('hidden');
      sceneTitle.classList.remove('hidden');
      overlayStack.classList.remove('overlayFadeOut');
      startTypingLine();
    }, Math.round(FADE_MS));
  }

  function startTypingLine(){
    if(typing) return;
    typing = true;
    typeLineEl.textContent = "";
    let i = 0;
    const s = TYPE_LINE;
    const timer = setInterval(()=>{
      i++;
      typeLineEl.textContent = s.slice(0,i);
      if(i >= s.length){
        clearInterval(timer);
      }
    }, TYPE_SPEED_MS);
  }

  async function onPermTap(e){
    if(e && e.preventDefault) e.preventDefault();
    await ensureResumed();
    playClick();

    // 권한 요청 + 워밍업 (권한 거절해도 다음 씬은 진행)
    await requestCameraPermission();
    await warmUp();

    fadeToTitle();
  }

  function fadeOutOverlay(){
    overlayStack.classList.add('overlayFadeOut');
    setTimeout(()=>{
      overlayStack.style.display = "none";
    }, Math.round(FADE_MS));
  }

  async function enterProgram(e){
    if(e && e.preventDefault) e.preventDefault();
    await ensureResumed();
    playClick();

    // 오버레이 페이드아웃(2.5s) + 카메라 페이드인(2.5s)
    fadeOutOverlay();

    try{
      await startCameraFresh();
      fadeInCamera(FADE_MS);
    }catch(err){
      log("camera start failed");
    }

    controls.classList.add('show');
    captureBtn.classList.add('show');

    runningDetect = true;
    lastT = performance.now();
    lastDetectAt = 0;
    tick();
  }

  // Scene 1 tap
  ['click','touchstart','pointerdown'].forEach(type=>{
    scenePerm.addEventListener(type, onPermTap, {passive:false});
  });

  // Scene 2 tap
  ['click','touchstart','pointerdown'].forEach(type=>{
    sceneTitle.addEventListener(type, enterProgram, {passive:false});
  });

})();
</script>
</body>
</html>
