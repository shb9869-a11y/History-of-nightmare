<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>History of Nightmare — ACT 1</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>
  :root{
    --frame: 40px; --ui-gap: 8px;
    --fs-body: clamp(12px, 2.0vmin, 15px);   /* 폰트 “안 크게” */
    --fs-strong: clamp(14px, 2.6vmin, 18px);
    --fs-small: clamp(11px, 1.7vmin, 13px);
    --pad-line: clamp(4px, 0.9vmin, 8px);
    --pad-btn-y: clamp(6px, 1.1vmin, 10px);
    --pad-btn-x: clamp(10px, 1.8vmin, 20px);
  }
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  #view{width:100%;height:100%;display:block;position:fixed;left:0;top:0;z-index:0}
  .frameBox{position:fixed;left:var(--frame);top:var(--frame);right:var(--frame);bottom:var(--frame);border:1px solid #000;pointer-events:none;z-index:50}
  .uiBtn{background:#000;color:#fff;border:1px solid #000;font-size:var(--fs-strong);padding:var(--pad-btn-y) var(--pad-btn-x);font-family:"Courier New",monospace;white-space:nowrap;cursor:pointer;user-select:none}
  .uiBtn.small{font-size:var(--fs-small);padding:calc(var(--pad-btn-y)*0.6) calc(var(--pad-btn-x)*0.6)}
  .controls{position:fixed;right:calc(var(--frame) + var(--ui-gap));bottom:calc(var(--frame) + var(--ui-gap));z-index:100;display:flex;gap:6px;align-items:center}
  .readout{min-width:48px;text-align:center;opacity:.9;font-family:"Courier New",monospace;font-size:var(--fs-small)}
  .btn-capture{position:fixed;left:calc(var(--frame) + var(--ui-gap));bottom:calc(var(--frame) + var(--ui-gap));z-index:150}
  #overlay{position:fixed;inset:0;z-index:200;display:flex;align-items:center;justify-content:center;padding:20px;font-family:"Courier New",monospace;color:#fff;pointer-events:none}
  #overlayContent{pointer-events:auto;line-height:1.7;font-size:var(--fs-body);max-width:min(74ch, calc(100vw - (var(--frame)*2)));max-height:calc(100vh - (var(--frame)*2));overflow:hidden;text-align:left}
  .line{display:inline;background:#000;color:#fff;padding:calc(var(--pad-line)*0.8) var(--pad-line);box-decoration-break:clone;-webkit-box-decoration-break:clone}
  .lineWrap{margin:6px 0}
  .fade{opacity:1;transition:opacity .45s ease}
  .fade.hidden{opacity:0}
  #goodnight{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:250;display:none;text-align:center;font-family:"Courier New",monospace;font-size:clamp(18px,3.2vmin,26px);color:#fff;background:#000;padding:var(--pad-btn-y) var(--pad-btn-x);white-space:nowrap;transition:opacity .6s ease}
  #goodnight.show{display:block;opacity:1}
  #goodnight.fadeout{opacity:0}
  /* ACT 1 컷-인 */
  #act1{position:fixed;inset:0;z-index:260;display:none;align-items:center;justify-content:center;background:#000;color:#fff;font-family:"Courier New",monospace}
  #act1.show{display:flex;animation:cutin .35s ease-out}
  #act1 h1{font-size:clamp(28px,8vmin,96px);letter-spacing:0.06em;margin:0}
  @keyframes cutin{from{transform:scale(0.96);opacity:.0} to{transform:scale(1);opacity:1}}
  @media (orientation:landscape){ :root{ --frame: 32px; } }
  .tip{opacity:.7;font-size:var(--fs-small);margin-top:8px}
</style>
</head>
<body>
  <canvas id="view"></canvas>
  <div class="frameBox" aria-hidden="true"></div>

  <div class="controls">
    <button class="uiBtn small" id="zoomOut">–</button>
    <div class="readout"><span id="zoomVal">1.2×</span></div>
    <button class="uiBtn small" id="zoomIn">+</button>
  </div>

  <button id="captureBtn" class="uiBtn small btn-capture">CAPTURE</button>

  <div id="overlay" class="fade">
    <div id="overlayContent" class="fade">
      <!-- 1단계: Welcome 버튼 -->
      <button id="welcomeBtn" class="uiBtn">Welcome to History of Nightmare</button>
      <div class="tip" id="sensorTip" style="display:none">센서 권한 필요: 버튼을 누르면 허용 팝업이 뜹니다.</div>
    </div>
  </div>

  <div id="goodnight">GOOD NIGHT</div>
  <div id="act1"><h1>ACT 1 : 발굴</h1></div>

<script>
(async ()=>{
  /* ========= 카메라(흑백+잔상) ========= */
  const view=document.getElementById('view');
  const vctx=view.getContext('2d',{alpha:false});
  const PROC_SCALE=0.60, TRAIL_ALPHA=0.12, GLOBAL_ALPHA=0.7;
  let ZOOM=1.2, ZOOM_MIN=0.5, ZOOM_MAX=3.0, ZOOM_STEP=0.1;

  const zoomVal=document.getElementById('zoomVal');
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const updateZoom=()=>zoomVal.textContent=ZOOM.toFixed(1)+'×';
  document.getElementById('zoomIn').onclick=()=>{ZOOM=clamp(ZOOM+ZOOM_STEP,ZOOM_MIN,ZOOM_MAX);updateZoom();};
  document.getElementById('zoomOut').onclick=()=>{ZOOM=clamp(ZOOM-ZOOM_STEP,ZOOM_MIN,ZOOM_MAX);updateZoom();};
  updateZoom();

  const camVideo=document.createElement('video'); camVideo.autoplay=true; camVideo.playsInline=true; camVideo.muted=true;
  const proc=document.createElement('canvas'); const pctx=proc.getContext('2d',{willReadFrequently:true});

  async function attachCamera(){
    try{
      const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
      camVideo.srcObject=s; await camVideo.play().catch(()=>{});
    }catch(e){console.warn("카메라 실패:", e);}
  }
  function resizeAll(){
    const dpr=window.devicePixelRatio||1;
    const w=window.innerWidth,h=window.innerHeight;
    view.width=w*dpr; view.height=h*dpr; vctx.setTransform(dpr,0,0,dpr,0,0);
    const scale=(window.matchMedia('(orientation: landscape)').matches)? PROC_SCALE*0.9 : PROC_SCALE;
    proc.width=Math.floor(w*scale); proc.height=Math.floor(h*scale);
  }
  resizeAll(); addEventListener('resize',()=>setTimeout(resizeAll,50));

  function loop(){
    requestAnimationFrame(loop);
    const W=view.width/(window.devicePixelRatio||1);
    const H=view.height/(window.devicePixelRatio||1);
    const PW=proc.width, PH=proc.height;
    pctx.globalCompositeOperation="source-over";
    pctx.fillStyle=`rgba(0,0,0,${TRAIL_ALPHA})`; pctx.fillRect(0,0,PW,PH);
    if(camVideo.readyState>=2){
      const vw=camVideo.videoWidth, vh=camVideo.videoHeight;
      if(vw && vh){
        const base=Math.max(PW/vw,PH/vh), sc=base*ZOOM;
        const dw=vw*sc, dh=vh*sc, dx=(PW-dw)/2, dy=(PH-dh)/2;
        pctx.globalAlpha=GLOBAL_ALPHA; pctx.drawImage(camVideo,dx,dy,dw,dh);
        pctx.globalAlpha=1.0;
        const frame=pctx.getImageData(0,0,PW,PH); const d=frame.data;
        for(let i=0;i<d.length;i+=4){
          const g=(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2])|0; d[i]=d[i+1]=d[i+2]=g;
        }
        pctx.putImageData(frame,0,0);
      }
    }
    vctx.drawImage(proc,0,0,W,H);
  }
  await attachCamera(); loop();

  /* ========= 오디오(마이크만 — 모션 패닝/볼륨) ========= */
  let audioCtx=null, micStream=null, motionGain=null, panSetter=null;

  const VOL_BASE=0.22, VOL_MAX_ADD=0.55;
  const SMOOTH_TC=0.08, CTRL_SMOOTH_ALPHA=0.12;
  const DEADZONE_VOL_DEG=5, DEADZONE_PAN_DEG=3, VOL_TILT_LIMIT=60, PAN_LIMIT_DEG=45;

  function initAudioChain(){
    if(audioCtx) return;
    audioCtx=new (window.AudioContext||window.webkitAudioContext)();

    // 패너
    let panOut=null;
    if (audioCtx.createStereoPanner){
      const sp=audioCtx.createStereoPanner();
      panSetter=(val)=>{ try{ sp.pan.setTargetAtTime(val, audioCtx.currentTime, 0.08);}catch{ sp.pan.value=val; } };
      panOut=sp;
    }else{
      // 폴백 L/R 게인
      const l=audioCtx.createGain(), r=audioCtx.createGain(), m=audioCtx.createChannelMerger(2);
      l.connect(m,0,0); r.connect(m,0,1);
      panSetter=(p)=>{
        const x=Math.max(-1,Math.min(1,p||0));
        const th=(x+1)*0.25*Math.PI;
        const gL=Math.cos(th), gR=Math.sin(th);
        try{ l.gain.setTargetAtTime(gL,audioCtx.currentTime,0.08); r.gain.setTargetAtTime(gR,audioCtx.currentTime,0.08); }
        catch{ l.gain.value=gL; r.gain.value=gR; }
      };
      panOut=m;
    }

    // 모션 대역 볼륨
    motionGain=audioCtx.createGain(); motionGain.gain.value=VOL_BASE;
    panOut.connect(motionGain).connect(audioCtx.destination);
  }

  async function startMicOnly(){
    if(micStream) return;
    const s=await navigator.mediaDevices.getUserMedia({audio:true, video:false});
    const src=audioCtx.createMediaStreamSource(s);
    micStream=s;
    // 이펙트 없이 바로 패너로
    src.connect( (panSetter ? (function(){
      // 패너 입력 노드 찾기
      // 위에서 createStereoPanner나 폴백을 만들 때, 입력은 panOut의 “앞”입니다.
      // 간단히 다시 구성:
      const inGain=audioCtx.createGain();
      inGain.connect(motionGain); // motionGain 앞에 붙이기
      // panSetter는 motionGain “앞단”에서 동작하게 이미 연결되어 있으니 별도 변경 불필요
      return inGain;
    })(): motionGain) );
  }

  /* ========= 센서(기울기 → 패닝/볼륨) ========= */
  let sensorsReady=false;
  const sensorTip=document.getElementById('sensorTip');

  async function requestMotionPermissions(){
    try{
      if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){
        const r=await DeviceOrientationEvent.requestPermission();
        if(r==='granted') sensorsReady=true;
      }else{ sensorsReady=true; }
    }catch(e){}
    try{
      if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
        const r=await DeviceMotionEvent.requestPermission();
        if(r==='granted') sensorsReady=true;
      }
    }catch(e){}
    sensorTip.style.display = sensorsReady? 'none':'block';
    return sensorsReady;
  }

  let latestOri={beta:0,gamma:0}, smVol=VOL_BASE, smPan=0;

  function getScreenAngle(){
    const o=(screen.orientation&&screen.orientation.angle)??window.orientation??0;
    return (typeof o==='number')?o:0;
  }
  function mapOrientation(beta,gamma){
    const ang=((getScreenAngle()%360)+360)%360;
    let volTilt=0, panTilt=0;
    if(ang===0){volTilt=beta; panTilt=gamma;}
    else if(ang===90){volTilt=-gamma; panTilt=beta;}
    else if(ang===180){volTilt=-beta; panTilt=-gamma;}
    else if(ang===270){volTilt=gamma; panTilt=-beta;}
    return {volTilt, panTilt};
  }
  function tiltToPan(panTilt){
    const t=Math.min(PAN_LIMIT_DEG, Math.max(-PAN_LIMIT_DEG, panTilt||0));
    if(Math.abs(t)<DEADZONE_PAN_DEG) return 0;
    return t/PAN_LIMIT_DEG;
  }
  function tiltToVol(volTilt){
    const t=Math.min(VOL_TILT_LIMIT, Math.max(-VOL_TILT_LIMIT, volTilt||0));
    const a=Math.max(0, Math.abs(t)-DEADZONE_VOL_DEG)/(VOL_TILT_LIMIT-DEADZONE_VOL_DEG);
    return VOL_BASE + VOL_MAX_ADD*a;
  }
  function smoothStep(t,c,a=CTRL_SMOOTH_ALPHA){ return c+(t-c)*a; }

  function applyPanVol(pan, vol){
    if(!audioCtx) return;
    const now=audioCtx.currentTime;
    if(panSetter){
      try{ panSetter(pan); }catch{}
    }
    if(motionGain){
      try{ motionGain.gain.setTargetAtTime(vol, now, SMOOTH_TC); }
      catch{ motionGain.gain.cancelScheduledValues(now); motionGain.gain.linearRampToValueAtTime(vol, now+0.08); }
    }
  }

  function initOrientationListener(){
    if(typeof DeviceOrientationEvent==='undefined') return;
    window.addEventListener('deviceorientation',(e)=>{
      latestOri.beta=e.beta??0; latestOri.gamma=e.gamma??0;
    },{passive:true});
  }

  function controlLoop(){
    requestAnimationFrame(controlLoop);
    let pan=0, vol=VOL_BASE;
    if(sensorsReady){
      const {volTilt, panTilt}=mapOrientation(latestOri.beta, latestOri.gamma);
      vol=smoothStep(tiltToVol(volTilt), smVol);
      pan=smoothStep(tiltToPan(panTilt), smPan);
      smVol=vol; smPan=pan;
    }else{
      vol=smoothStep(VOL_BASE, smVol); pan=smoothStep(0, smPan);
      smVol=vol; smPan=pan;
    }
    applyPanVol(pan, vol);
  }

  /* ========= 오버레이 흐름 ========= */
  const overlay=document.getElementById('overlay');
  const overlayContent=document.getElementById('overlayContent');
  const welcomeBtn=document.getElementById('welcomeBtn');
  const goodnight=document.getElementById('goodnight');
  const act1=document.getElementById('act1');

  function lineHTML(s){ return `<div class="lineWrap"><span class="line">${s}</span></div>`; }
  function crossfade(html, next){
    overlayContent.classList.add('hidden');
    setTimeout(()=>{ overlayContent.innerHTML=html; overlayContent.classList.remove('hidden'); next&&next(); }, 450);
  }

  // 1) Welcome → 2) PRESS HERE TO SLEEP
  welcomeBtn.addEventListener('click', async ()=>{
    // 사운드 안 끊기게: 첫 버튼에서 오디오 시작/권한 요청
    initAudioChain();
    if(audioCtx.state==='suspended'){ try{ await audioCtx.resume(); }catch{} }
    await startMicOnly().catch(()=>{});
    initOrientationListener();
    await requestMotionPermissions();
    controlLoop();

    crossfade(`<button id="startBtn" class="uiBtn">PRESS HERE TO SLEEP</button>`, ()=>{
      document.getElementById('startBtn').addEventListener('click', runSequence);
    });
  });

  // 3) 시퀀스(3초 간격, 페이드)
  const seq = [
    '이 모든 이야기는 내가 나를 매장하는 독특한 의식으로부터 시작되었다.',
    { // 클릭 시 문구 교체
      text: "때는 2023년 11월 20일.",
      clickableAlt: "우리는 우리 스스로를 매장하는 독특한 의식을 치루었다."
    },
    '그 절차는 다음과 같다.',
    '우선 우리는 각각 두 개의 하얀 종이에 우리의 나쁜 생각과 좋은 생각을 적어 내려갔다.',
    '집, 돈, 사랑, 꿈, 이름 따위의 것들 말이다.',
    '그리곤 그 위로 여러 장의 종이를 덧대어 하나의 ‘뇌’를 만들었고,',
    '그다음엔 더 많은 종이를 덧대어 하나의 머리를 만들었다.',
    '또, 그다음엔 더욱더 많이 종이를 덧대어 몸과 팔과 다리와 성기와 젖꼭지 등을 만들어 제법 사람의 형태를 띄도록 만들었다.',
    '이것이 완성되었을 때, 우리는 이것을 ‘또 다른 우리’라고 불렀다.',
    '다음날, 우리는 각자 작은 나무를 한 그루씩 구해왔다.',
    '그리고 ‘또 다른 우리’를 데리고 흔히 우리가 ‘뒷산’이라고 불렀던 공간을 향해 올라갔다.',
    '적당한 위치에 도착한 우리는 삽을 이용해 구덩이를 팠다.',
    '어느 정도 ‘또 다른 우리‘가 들어갈 수 있을 정도의 구덩이가 파졌을 때,',
    '우리는 그것들을 구덩이에 넣고 불로 태워 재로 만들었다.',
    '재가 되어버린 ’또 다른 우리‘ 위로 흙을 덮었으며,',
    '미리 구해온 나무를 그 위에 심었다.',
    '우리는 나무를 둘러싸고 선 채로 손을 맞잡았다.',
    '그때, 누군가는 소원을 빌었으며, 누군가는 노래를 불렀고, 누군가는 춤을 추었으며, 누군가는 눈물을 흘리기도 했다.',
    '그건 정확히 2022년 11월 20일의 기억이었다.',
    '내가 이 기억을 ’악몽‘이라고 부르게 된 계기는 이로부터 약 6개월이 흐른 시점부터 시작된다.',
    '꿈속의 나는 우리가 흔히 ’뒷산‘이라고 부르던 공간에서 깨어난다.',
    '그곳에서 나는 생명의 존재를 느낄 수 없으며, 오히려 오롯이 나 혼자만이 존재하고 있다고 느낀다.',
    '그러던 순간 나는 마치 무엇인가 나에게 달려와 안길 것만 같은 느낌을 받는다.',
    '그러나 나는 그것이 누군인지 알지 못한다.',
    '설렘과 초조함으로 시작되었던 이 반복되는 꿈.',
    '그러나 이것이 아침이 되어 출근을 해야 하는 시점까지 반복되어야만 한다는 것을 깨달았을 때,',
    '나는 이것을 악몽이라 부르기 시작했다.',
    '왜냐하면. 나에겐 어딘가로 도망가거나, 숨거나, 거부하거나 할 수 있는 도리란 존재하지 않았기 때문이다.'
  ];

  function runSequence(){
    let i=0, timer=null;

    function showItem(){
      if(i>=seq.length){ endSequence(); return; }
      const item=seq[i++];
      if(typeof item==="string"){
        crossfade( lineHTML(item), nextStep );
      }else{
        // 클릭 교체 항목
        const html = `<div class="lineWrap"><span class="line clickable" id="altLine" style="cursor:pointer">${item.text}</span></div>`;
        crossfade(html, ()=>{
          const el=document.getElementById('altLine');
          el.addEventListener('click', ()=>{
            el.textContent=item.clickableAlt;
          }, {once:true});
          nextStep();
        });
      }
    }
    function nextStep(){
      timer=setTimeout(showItem, 3000);
    }
    function endSequence(){
      // GOOD NIGHT 3초
      goodnight.classList.add('show');
      setTimeout(()=>{ goodnight.classList.add('fadeout'); }, 2500);
      setTimeout(()=>{ goodnight.classList.remove('show','fadeout'); goodnight.style.display='none'; showAct1(); }, 3200);
      // 오버레이 텍스트는 감춤
      overlay.classList.add('hidden');
      setTimeout(()=>{ overlay.style.display='none'; },450);
      if(timer){ clearTimeout(timer); }
    }
    showItem();
  }

  function showAct1(){
    act1.classList.add('show');
  }

  /* ========= 자동 시작: 카메라만 선시작 ========= */
  document.getElementById('captureBtn').addEventListener('click',()=>{
    try{ const a=document.createElement('a'); a.download=`capture_${Date.now()}.png`; a.href=view.toDataURL('image/png'); a.click(); }
    catch(e){ console.warn('CAPTURE 실패', e); }
  });

})();
</script>
</body>
</html>
