<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,interactive-widget=resizes-content">
<title>LIMEN</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="LIMEN">
<meta name="theme-color" content="#000000">

<!-- ✅ BOX DETECT libs -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>

<style>
:root{
  --frame: clamp(16px, 4vmin, 40px);
  --ui-gap: 8px;
  --fs-strong: clamp(14px, 2.6vmin, 18px);
  --fs-small: clamp(11px, 1.8vmin, 13px);
  --pad-btn-y: clamp(8px, 1.1vmin, 12px);
  --pad-btn-x: clamp(12px, 1.8vmin, 20px);
  --safe-t: env(safe-area-inset-top, 0px);
  --safe-b: env(safe-area-inset-bottom, 0px);
  --safe-l: env(safe-area-inset-left, 0px);
  --safe-r: env(safe-area-inset-right, 0px);

  --fade: 2500ms;
}

html,body{
  margin:0; padding:0; width:100%; height:100%;
  background:#000; overflow:hidden;
  touch-action:manipulation;
}
body{
  font-family: -apple-system, BlinkMacSystemFont,
               "SF Pro Display", "SF Pro Text",
               "Apple SD Gothic Neo", "Noto Sans",
               "Noto Sans KR", "Helvetica Neue", Arial, sans-serif;
  font-weight: 300;
  -webkit-user-select:none; user-select:none;
  -webkit-touch-callout:none;
  color:#fff;
}
*{
  box-sizing:border-box;
  -webkit-user-select:none; user-select:none;
  -webkit-touch-callout:none;
  -webkit-tap-highlight-color: transparent;
}

#bg{
  position:fixed; inset:0;
  width:100vw; height:100vh;
  display:block;
  z-index:0;
  background:#000;
}

#view{
  position:fixed; inset:0;
  width:100vw; height:100vh;
  display:block; z-index:2;
  filter:grayscale(1);
}

#freezeLayer{
  position:fixed; inset:0;
  z-index:500;
  display:none;
}

/* frame */
.frameBox{
  position:fixed;
  left:calc(var(--frame) + var(--safe-l));
  top:calc(var(--frame) + var(--safe-t));
  right:calc(var(--frame) + var(--safe-r));
  bottom:calc(var(--frame) + var(--safe-b));
  border:1.5px solid rgba(255,255,255,.62);
  pointer-events:none;
  z-index:50;
}

/* bottom controls */
.uiBtn{
  background:transparent;
  color:#fff;
  border:none;
  font-size:var(--fs-strong);
  padding:var(--pad-btn-y) var(--pad-btn-x);
  font-family: inherit;
  font-weight: 300;
  letter-spacing: .10em;
  white-space:nowrap;
  cursor:pointer;
  opacity:.92;
}
.uiBtn.small{
  font-size:var(--fs-small);
  padding:calc(var(--pad-btn-y)*0.75) calc(var(--pad-btn-x)*0.75);
}
.uiBtn:active{opacity:.75; transform:translateY(1px);}
.uiBtn[disabled]{ opacity:.35; pointer-events:none; filter:grayscale(1); }

.controls{
  position:fixed;
  right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
  bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
  z-index:400;
  display:flex;
  gap:6px;
  align-items:center;
  opacity:0;
  transition:opacity var(--fade) ease;
}
.controls.show{opacity:1}
.readout{
  min-width:64px;
  text-align:center;
  opacity:.85;
  font-size:var(--fs-small);
  color:#fff;
  font-family: inherit;
  font-weight: 300;
}

.btn-capture{
  position:fixed;
  left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
  bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b));
  z-index:450;
  opacity:0;
  transition:opacity var(--fade) ease;
}
.btn-capture.show{opacity:1}

.sleep-status-text{
  position:fixed;
  left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
  bottom:calc(var(--frame) + var(--ui-gap) + var(--safe-b) + 34px);
  z-index:451;
  font-size:var(--fs-small);
  font-weight: 300;
  color:rgba(255,255,255,.65);
  text-shadow:0 0 6px rgba(0,0,0,0.7);
  max-width:min(76vw, 720px);
  letter-spacing:.04em;
}

/* =========================
   ✅ BOX DETECT UI (kept)
   ========================= */
#toggleUI{
  position:fixed;
  right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
  top:calc(var(--frame) + var(--ui-gap) + var(--safe-t));
  z-index:920;
  background:transparent;
  border:none;
  padding:0;
  color:#fff;
  letter-spacing:.16em;
  font-family: inherit;
  font-weight: 300;
  opacity:.85;
  cursor:pointer;
}
#toggleUI:active{opacity:.62; transform:translateY(1px);}

#ui{
  position:fixed;
  right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
  top:calc(var(--frame) + var(--ui-gap) + var(--safe-t) + 34px);
  z-index:910;

  width:min(300px, calc(100vw - (var(--frame)*2) - 24px));
  max-height:calc(100vh - (var(--frame)*2) - 120px);
  overflow:auto;

  background:rgba(0,0,0,.38);
  border:1px solid rgba(255,255,255,.12);
  border-radius:18px;
  padding:12px;
  backdrop-filter: blur(10px);

  display:flex;
  flex-direction:column;
  gap:10px;
  pointer-events:auto;
  transition:.2s;

  font-family: inherit;
  font-weight: 300;
}
#ui.hidden{opacity:0; pointer-events:none; transform:translateY(-10px);}

.pill{
  display:grid;
  grid-template-columns: 92px 1fr auto;
  gap:10px;
  align-items:center;
  background:rgba(255,255,255,.045);
  border:1px solid rgba(255,255,255,.10);
  border-radius:16px;
  padding:10px 12px;
  color:rgba(255,255,255,.85);
}
.pill b{
  color:#fff;
  font-weight: 500;
  letter-spacing:.12em;
}
.pill input[type=range]{width:100%;}
.pill label{
  grid-column: 1 / -1;
  display:flex;
  align-items:center;
  gap:10px;
}
#ui button{
  appearance:none;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.06);
  color:#fff;
  padding:10px 12px;
  border-radius:14px;
  font-weight: 300;
  pointer-events:auto;
}
#ui button:active{transform:translateY(1px);}

/* status */
#log{
  position:fixed;
  left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
  top:calc(var(--frame) + var(--ui-gap) + var(--safe-t));
  z-index:905;
  font-size:10px;
  background:rgba(0,0,0,.12);
  border:1px solid rgba(255,255,255,.08);
  border-radius:12px;
  padding:6px 10px;
  backdrop-filter: blur(10px);
  max-width:min(86vw,820px);
  white-space:pre-wrap;
  pointer-events:none;
  color:rgba(255,255,255,.55);
  opacity:.35;
  font-family: inherit;
  font-weight: 300;
}

/* =========================
   ✅ INTRO overlay (morphing white circle + text)
   ========================= */
#intro{
  position:fixed; inset:0;
  z-index:800;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#000;
  pointer-events:auto;
  opacity:1;
  transition:opacity var(--fade) ease;
}
#intro.hidden{
  opacity:0;
  pointer-events:none;
}
#introCanvas{
  position:absolute; inset:0;
  width:100vw; height:100vh;
  display:block;
}
#introTextWrap{
  position:absolute;
  left:calc(var(--frame) + var(--safe-l));
  right:calc(var(--frame) + var(--safe-r));
  top:50%;
  transform:translateY(-50%);
  text-align:center;
  padding: 0 10px;
  pointer-events:none;
}
#introTitle{
  font-size: clamp(16px, 3.4vmin, 22px);
  letter-spacing:.06em;
  color:rgba(255,255,255,.92);
  text-shadow:0 0 18px rgba(0,0,0,.75);
  margin:0 0 10px 0;
  font-weight: 300;
}
#introSub{
  font-size: clamp(12px, 2.2vmin, 15px);
  letter-spacing:.06em;
  color:rgba(255,255,255,.72);
  text-shadow:0 0 18px rgba(0,0,0,.75);
  margin:0;
  font-weight: 300;
  line-height:1.45;
}
</style>
</head>

<body>
  <canvas id="bg"></canvas>
  <canvas id="view"></canvas>
  <canvas id="freezeLayer"></canvas>

  <div class="frameBox" aria-hidden="true"></div>

  <div class="controls" id="controls">
    <button class="uiBtn small" id="zoomOut">–</button>
    <div class="readout"><span id="zoomVal">1.0×</span></div>
    <button class="uiBtn small" id="zoomIn">+</button>
  </div>

  <button id="captureBtn" class="uiBtn small btn-capture">Capture</button>
  <div id="sleepPhotoStatus" class="sleep-status-text"></div>

  <!-- ✅ BOX DETECT UI -->
  <button id="toggleUI">MENU</button>
  <div id="ui" class="hidden">
    <div class="pill">
      <b>COARSE</b>
      <input id="conf" type="range" min="0.01" max="0.95" step="0.01" value="0.12">
      <span id="confVal">0.12</span>
    </div>

    <div class="pill">
      <b>FINE</b>
      <input id="fine" type="range" min="0.00" max="1.00" step="0.01" value="0.40">
      <span id="fineVal">0.40</span>
    </div>

    <div class="pill">
      <b>N</b>
      <input id="topN" type="range" min="3" max="8" step="1" value="4">
      <span id="topNVal">4</span>
    </div>

    <div class="pill">
      <b>HOLD</b>
      <input id="holdSec" type="range" min="1" max="10" step="0.5" value="3.0">
      <span id="holdVal">3.0s</span>
    </div>

    <div class="pill">
      <b>BOX</b>
      <input id="boxScale" type="range" min="0.35" max="1.20" step="0.01" value="0.40">
      <span id="boxScaleVal">0.40</span>
    </div>

    <div class="pill">
      <label><input id="links" type="checkbox" checked> Links</label>
      <label><input id="fillFrag" type="checkbox" checked> Fragments</label>
    </div>

    <div class="pill" style="grid-template-columns: 1fr 1fr; gap:10px;">
      <button id="flip">Flip</button>
      <button id="restart">Restart</button>
    </div>

    <div class="pill" style="grid-template-columns: 92px 1fr; gap:10px;">
      <b>Source</b>
      <div style="display:flex; gap:10px; align-items:center; justify-content:flex-end;">
        <label style="display:flex; align-items:center; gap:8px;">
          <input id="videoFile" type="file" accept="video/*" style="max-width:160px;">
          <span style="opacity:.9">Upload</span>
        </label>
        <button id="useCam">Camera</button>
      </div>
    </div>

    <div class="pill" style="grid-template-columns: 1fr; gap:6px;">
      <span id="status"></span>
      <span id="fps"></span>
      <span id="count"></span>
    </div>
  </div>

  <div id="log"></div>

  <!-- ✅ INTRO -->
  <div id="intro">
    <canvas id="introCanvas"></canvas>
    <div id="introTextWrap">
      <p id="introTitle">Welcome. Thank you for participating in the program.</p>
      <p id="introSub">Tap anywhere to allow the camera.</p>
    </div>
  </div>

<script>
(() => {
  /* =========================
     ✅ server / timing
     ========================= */
  const SLEEP_UPLOAD_SERVER = 'https://172.20.10.7:4443';
  const UPLOAD_TIMEOUT_MS = 12000;
  const UPLOAD_RETRY = 1;

  const FADE_MS = 2500;

  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const qs = s => document.querySelector(s);
  const lerp=(a,b,t)=>a+(b-a)*t;
  const lerpBox=(cur,target,t)=>[lerp(cur[0],target[0],t),lerp(cur[1],target[1],t),lerp(cur[2],target[2],t),lerp(cur[3],target[3],t)];

  document.addEventListener('contextmenu', e=>e.preventDefault());
  document.addEventListener('selectstart', e=>e.preventDefault());

  /* =========================
     click sfx
     ========================= */
  let audioCtx = null;
  function ensureAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  async function ensureResumed(){
    ensureAudio();
    if(audioCtx.state === 'suspended'){
      try{ await audioCtx.resume(); }catch(e){}
    }
  }
  const MASTER_SFX_GAIN = 0.18;
  async function playClick(){
    try{
      await ensureResumed();
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type='sine';
      o.frequency.setValueAtTime(190, now);
      o.frequency.exponentialRampToValueAtTime(140, now+0.12);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(MASTER_SFX_GAIN, now+0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now+0.18);
      o.connect(g).connect(audioCtx.destination);
      o.start(now);
      o.stop(now+0.2);
    }catch(e){}
  }

  /* =========================
     DOM
     ========================= */
  const controls = qs('#controls');
  const zoomIn = qs('#zoomIn');
  const zoomOut = qs('#zoomOut');
  const zoomVal = qs('#zoomVal');
  const captureBtn = qs('#captureBtn');

  const bg = qs('#bg');
  const view = qs('#view');
  const freezeLayer = qs('#freezeLayer');

  const sleepPhotoStatus = qs('#sleepPhotoStatus');
  function setSleepPhotoStatus(msg){ sleepPhotoStatus.textContent = msg || ''; }

  const toggleUIBtn = qs('#toggleUI');
  const ui = qs('#ui');
  const logEl = qs('#log');

  const confEl = qs('#conf');
  const confVal = qs('#confVal');
  const fineEl = qs('#fine');
  const fineVal = qs('#fineVal');
  const topNEl = qs('#topN');
  const topNVal = qs('#topNVal');
  const holdSecEl = qs('#holdSec');
  const holdValEl = qs('#holdVal');
  const boxScaleEl = qs('#boxScale');
  const boxScaleValEl = qs('#boxScaleVal');

  const linksEl = qs('#links');
  const fillFragEl = qs('#fillFrag');

  const flipBtn = qs('#flip');
  const restartBtn = qs('#restart');
  const useCamBtn = qs('#useCam');
  const videoFileEl = qs('#videoFile');

  const statusEl = qs('#status');
  const fpsEl = qs('#fps');
  const countEl = qs('#count');

  // intro
  const intro = qs('#intro');
  const introTitle = qs('#introTitle');
  const introSub = qs('#introSub');
  const introCanvas = qs('#introCanvas');
  const ictx = introCanvas.getContext('2d', { alpha:false });

  function log(msg){ logEl.textContent = String(msg ?? ''); }

  toggleUIBtn.addEventListener('click', ()=>{
    const hidden = ui.classList.toggle('hidden');
    toggleUIBtn.textContent = hidden ? 'MENU' : 'CLOSE';
    playClick();
  }, {passive:true});

  /* =========================
     ✅ INTRO: morphing white circle (plane -> sphere -> cone -> ...
     ========================= */
  function resizeIntroCanvas(){
    const dpr = window.devicePixelRatio || 1;
    introCanvas.width = Math.round(innerWidth * dpr);
    introCanvas.height = Math.round(innerHeight * dpr);
    ictx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resizeIntroCanvas, {passive:true});
  window.addEventListener('orientationchange', resizeIntroCanvas, {passive:true});
  resizeIntroCanvas();

  // Simple faux-3D shading using radial gradient + deform outline
  function drawMorph(t){
    const W = innerWidth, H = innerHeight;
    ictx.fillStyle = '#000';
    ictx.fillRect(0,0,W,H);

    const cx = W*0.5;
    const cy = H*0.46;

    // slow cycle across states
    const s = (Math.sin(t*0.17)+1)*0.5; // 0..1
    const u = (Math.sin(t*0.11 + 1.7)+1)*0.5;

    const baseR = Math.min(W,H) * (0.14 + 0.03*Math.sin(t*0.23));
    const wob = 0.10 + 0.10*Math.sin(t*0.47); // jelly amount
    const ripple = 0.22*Math.sin(t*0.58);

    // mode weights: plane, sphere, cone (blend)
    const wPlane = clamp(1.25 - 2.0*s, 0, 1);        // early
    const wSphere = 1.0 - Math.abs(s-0.5)*2.0;       // mid peak
    const wCone  = clamp(2.0*s - 0.25, 0, 1) * (1.0 - clamp(2.0*s - 1.75, 0, 1)); // late-mid
    const wCone2 = clamp(2.0*s - 1.1, 0, 1);         // later

    // outline deformation parameters
    const tilt = (u-0.5) * 0.8;
    const squash = 1.0 + 0.35*wPlane - 0.12*wSphere + 0.18*wCone;
    const stretchY = 1.0 + 0.05*wSphere + 0.45*wCone2; // cone grows taller

    // draw "surface" with points
    const N = 220;
    const pts = [];
    for(let i=0;i<=N;i++){
      const a = (i/N) * Math.PI*2;

      // base circle with jelly
      let r = baseR * (1 + wob*Math.sin(a*3 + t*0.9) + 0.04*Math.sin(a*7 + t*0.7));
      r *= (1 + 0.03*Math.sin(t*0.6 + a*2.0));

      // plane: flatten into ellipse
      const planeYScale = 0.35 + 0.25*Math.sin(t*0.2);
      const sy = lerp(1.0, planeYScale, wPlane);

      // cone: taper top (simulated by angle-dependent radial)
      const coneTaper = 1.0 - 0.55*wCone2 * (0.5 + 0.5*Math.sin(a + t*0.15));
      r *= lerp(1.0, coneTaper, wCone2);

      // extra “cone apex” illusion: pull top edge inward and upward
      const apexPull = wCone2 * Math.pow(Math.max(0, Math.sin(a - Math.PI/2)), 2.2);
      const r2 = r * (1.0 - 0.72*apexPull);

      // coordinates
      let x = Math.cos(a) * r2;
      let y = Math.sin(a) * r2 * sy;

      // general squash/stretch
      x *= squash;
      y *= stretchY;

      // subtle drift
      x += ripple * baseR * 0.08 * Math.sin(t*0.9 + a*4);
      y += ripple * baseR * 0.08 * Math.cos(t*0.8 + a*3);

      pts.push({x: cx + x, y: cy + y});
    }

    // faux shading: sphere uses radial gradient; plane uses thin highlight; cone uses vertical gradient
    ictx.save();

    // fill shape with gradient
    ictx.beginPath();
    ictx.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++) ictx.lineTo(pts[i].x, pts[i].y);
    ictx.closePath();

    const gx = cx + tilt*baseR*0.35;
    const gy = cy - baseR*0.15;
    const grad = ictx.createRadialGradient(gx, gy, baseR*0.12, cx, cy, baseR*1.35);

    // all white, but with alpha layers
    const a0 = 0.06 + 0.10*wPlane;
    const a1 = 0.18 + 0.22*wSphere;
    const a2 = 0.10 + 0.18*wCone2;

    grad.addColorStop(0.0, `rgba(255,255,255,${(0.65*a1 + 0.35*a2).toFixed(3)})`);
    grad.addColorStop(0.45, `rgba(255,255,255,${(0.22*a1 + 0.55*a2 + 0.15*a0).toFixed(3)})`);
    grad.addColorStop(1.0, `rgba(255,255,255,${(0.02 + 0.06*a0).toFixed(3)})`);

    ictx.fillStyle = grad;
    ictx.fill();

    // outline (pure white)
    ictx.strokeStyle = 'rgba(255,255,255,0.92)';
    ictx.lineWidth = Math.max(1.2, W/1200);
    ictx.stroke();

    // subtle inner rings for "3D"
    const rings = 3;
    for(let r=1;r<=rings;r++){
      const rr = r/(rings+1);
      const alpha = 0.08 + 0.10*wSphere + 0.10*wCone2;
      ictx.strokeStyle = `rgba(255,255,255,${(alpha*(1-rr)).toFixed(3)})`;
      ictx.beginPath();
      for(let i=0;i<pts.length;i++){
        const p = pts[i];
        const ix = lerp(cx, p.x, 1 - rr*0.55);
        const iy = lerp(cy, p.y, 1 - rr*0.55);
        if(i===0) ictx.moveTo(ix, iy);
        else ictx.lineTo(ix, iy);
      }
      ictx.closePath();
      ictx.stroke();
    }

    ictx.restore();

    requestAnimationFrame(()=>drawMorph(performance.now()*0.001));
  }
  requestAnimationFrame(()=>drawMorph(performance.now()*0.001));

  /* =========================
     ✅ Background: dreamy points (white)
     ========================= */
  const bctx = bg.getContext('2d', { alpha:false });
  const bgState = { pts: [], t0: performance.now(), swirl: 0, pulse: 0 };

  function resizeCanvas(c){
    const dpr = window.devicePixelRatio || 1;
    const w = innerWidth, h = innerHeight;
    c.width = Math.round(w * dpr);
    c.height = Math.round(h * dpr);
    const ctx = c.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  function resizeAll(){
    resizeCanvas(bg);
    const dpr=window.devicePixelRatio||1;
    const w=window.innerWidth;
    const h=window.innerHeight;
    view.width=w*dpr;
    view.height=h*dpr;
    const vctx = view.getContext('2d', { alpha:false });
    vctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resizeAll, {passive:true});
  window.addEventListener('orientationchange', resizeAll, {passive:true});
  resizeAll();

  function initBgPoints(){
    const W = innerWidth, H = innerHeight;
    const n = Math.round(clamp((W*H)/11000, 60, 140));
    bgState.pts = [];
    for(let i=0;i<n;i++){
      bgState.pts.push({
        x: Math.random()*W,
        y: Math.random()*H,
        vx: (Math.random()-0.5)*0.20,
        vy: (Math.random()-0.5)*0.20,
        r: 0.6 + Math.random()*1.4,
        k: Math.random()*6.28
      });
    }
  }
  initBgPoints();

  function bgLoop(){
    const W = innerWidth, H = innerHeight;
    const t = (performance.now() - bgState.t0) * 0.001;

    bgState.pulse = 0.5 + 0.5*Math.sin(t*0.65);
    bgState.swirl = 0.35*Math.sin(t*0.23);

    bctx.fillStyle = '#000';
    bctx.fillRect(0,0,W,H);

    const cx = W*0.52, cy = H*0.46;
    for(const p of bgState.pts){
      const dx = p.x - cx, dy = p.y - cy;
      const ang = Math.atan2(dy, dx) + bgState.swirl*0.35;
      const pull = 0.0006 * (0.6 + bgState.pulse);

      p.vx += -Math.cos(ang+Math.PI/2) * pull * (Math.abs(dx)+120);
      p.vy += -Math.sin(ang+Math.PI/2) * pull * (Math.abs(dy)+120);

      p.vx += 0.03*Math.sin(t*0.9 + p.k) * 0.02;
      p.vy += 0.03*Math.cos(t*0.8 + p.k) * 0.02;

      p.vx *= 0.985; p.vy *= 0.985;
      p.x += p.vx; p.y += p.vy;

      if(p.x < -20) p.x = W+20;
      if(p.x > W+20) p.x = -20;
      if(p.y < -20) p.y = H+20;
      if(p.y > H+20) p.y = -20;
    }

    const maxDist = Math.min(W,H) * (0.18 + 0.07*bgState.pulse);
    const maxD2 = maxDist*maxDist;

    bctx.save();
    bctx.globalCompositeOperation = 'lighter';

    for(let i=0;i<bgState.pts.length;i++){
      const a = bgState.pts[i];
      for(let j=i+1;j<bgState.pts.length;j++){
        const b = bgState.pts[j];
        const dx = a.x-b.x, dy = a.y-b.y;
        const d2 = dx*dx+dy*dy;
        if(d2 > maxD2) continue;

        const d = Math.sqrt(d2);
        const alpha = clamp(1 - (d/maxDist), 0, 1);
        const w = 0.6 + alpha*0.9;

        bctx.lineWidth = w;
        bctx.strokeStyle = `rgba(255,255,255,${(0.03 + 0.20*alpha).toFixed(3)})`;
        bctx.beginPath();
        bctx.moveTo(a.x, a.y);
        bctx.lineTo(b.x, b.y);
        bctx.stroke();
      }
    }

    for(const p of bgState.pts){
      const glow = 0.22 + 0.55*bgState.pulse;
      bctx.fillStyle = `rgba(255,255,255,${(0.16*glow).toFixed(3)})`;
      bctx.beginPath();
      bctx.arc(p.x, p.y, p.r*(0.9+0.35*bgState.pulse), 0, Math.PI*2);
      bctx.fill();
    }

    bctx.restore();
    requestAnimationFrame(bgLoop);
  }
  requestAnimationFrame(bgLoop);

  /* =========================
     Camera / detect
     ========================= */
  const vctx = view.getContext('2d', { alpha:false });

  let camStream=null;
  let camVideo=null;
  let facingMode='environment';
  let usingUploadVideo=false;

  let ZOOM=1.0;
  let showCamera=false;
  let camFadeAlpha=0;

  function updateZoomLabel(){ zoomVal.textContent = ZOOM.toFixed(1)+'×'; }
  updateZoomLabel();

  zoomIn.addEventListener('click', async ()=>{
    await ensureResumed();
    ZOOM=Math.min(3.0, ZOOM+0.1);
    updateZoomLabel();
    playClick();
  }, {passive:true});

  zoomOut.addEventListener('click', async ()=>{
    await ensureResumed();
    ZOOM=Math.max(1.0, ZOOM-0.1);
    updateZoomLabel();
    playClick();
  }, {passive:true});

  async function startCameraFresh(){
    usingUploadVideo=false;
    if (camStream){
      camStream.getTracks().forEach(t=>t.stop());
      camStream=null;
    }
    const s = await navigator.mediaDevices.getUserMedia({
      video:{
        facingMode:{ideal:facingMode},
        width:{min:1280,ideal:1920},
        height:{min:720,ideal:1080},
        aspectRatio:{ideal:16/9}
      },
      audio:false
    });
    camStream = s;

    if(!camVideo){
      camVideo=document.createElement('video');
      camVideo.setAttribute('playsinline','');
      camVideo.autoplay=true;
      camVideo.playsInline=true;
      camVideo.muted=true;
    }
    camVideo.srcObject=camStream;
    camVideo.src = '';
    await camVideo.play().catch(()=>{});
    if (camVideo.readyState < 1){
      await new Promise(res=>camVideo.addEventListener('loadedmetadata', res, {once:true}));
    }
  }

  async function useUploadedVideo(file){
    usingUploadVideo=true;
    if (camStream){
      camStream.getTracks().forEach(t=>t.stop());
      camStream=null;
    }
    if(!camVideo){
      camVideo=document.createElement('video');
      camVideo.setAttribute('playsinline','');
      camVideo.autoplay=true;
      camVideo.playsInline=true;
      camVideo.muted=true;
    }
    camVideo.srcObject=null;
    camVideo.loop=true;
    camVideo.muted=true;
    camVideo.src = URL.createObjectURL(file);
    await camVideo.play().catch(()=>{});
    if (camVideo.readyState < 1){
      await new Promise(res=>camVideo.addEventListener('loadedmetadata', res, {once:true}));
    }
  }

  function fadeInCamera(dur=FADE_MS){
    showCamera = true;
    const start = performance.now();
    camFadeAlpha = 0;
    function step(){
      const t = (performance.now() - start) / dur;
      camFadeAlpha = clamp(t, 0, 1);
      if(t < 1 && showCamera) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  function getCameraDrawTransform(){
    const w = view.clientWidth || innerWidth;
    const h = view.clientHeight || innerHeight;

    if(!camVideo || camVideo.readyState < 2) return null;
    const vw = camVideo.videoWidth, vh = camVideo.videoHeight;
    if(!vw || !vh) return null;

    const fw = w, fh = h;
    const videoRatio = vw / vh;
    const frameRatio = fw / fh;

    let dw, dh;
    if(videoRatio > frameRatio){ dh = fh; dw = dh * videoRatio; }
    else { dw = fw; dh = dw / videoRatio; }

    dw *= ZOOM; dh *= ZOOM;
    const dx = (fw - dw)/2;
    const dy = (fh - dh)/2;

    return { vw, vh, dx, dy, dw, dh, fw, fh };
  }

  /* =========================
     Upload
     ========================= */
  function humanErr(e){
    const msg = (e && e.message) ? e.message : String(e);
    if (/aborted/i.test(msg)) return "timeout";
    return msg;
  }
  async function canvasToJpegBlobResized(srcCanvas, maxLongSide=1600, quality=0.85){
    const w = srcCanvas.width;
    const h = srcCanvas.height;
    if (!w || !h) return null;

    const longSide = Math.max(w,h);
    const scale = Math.min(1, maxLongSide / longSide);

    const tw = Math.max(1, Math.round(w * scale));
    const th = Math.max(1, Math.round(h * scale));

    let target = srcCanvas;
    if (scale < 0.999){
      const c = document.createElement("canvas");
      c.width = tw;
      c.height = th;
      const cctx = c.getContext("2d");
      cctx.imageSmoothingEnabled = true;
      cctx.imageSmoothingQuality = "high";
      cctx.drawImage(srcCanvas, 0,0,w,h, 0,0,tw,th);
      target = c;
    }

    const blob = await new Promise((resolve) => {
      target.toBlob((b)=>resolve(b), "image/jpeg", quality);
    });
    return blob;
  }
  async function fetchWithTimeout(url, options={}, timeoutMs=UPLOAD_TIMEOUT_MS){
    const controller = new AbortController();
    const id = setTimeout(()=>controller.abort(new Error("aborted")), timeoutMs);
    try{
      const res = await fetch(url, { ...options, signal: controller.signal });
      return res;
    } finally {
      clearTimeout(id);
    }
  }
  async function uploadBlob(blob){
    const formData = new FormData();
    formData.append("image", blob, `sleep_capture_${Date.now()}.jpg`);
    const base = (SLEEP_UPLOAD_SERVER && SLEEP_UPLOAD_SERVER.trim()) ? SLEEP_UPLOAD_SERVER.trim() : '';
    const url = base + "/upload";

    let res = await fetchWithTimeout(url, { method:"POST", body: formData }, UPLOAD_TIMEOUT_MS);
    if ((!res.ok && res.status >= 500) && UPLOAD_RETRY > 0){
      await new Promise(r=>setTimeout(r, 400));
      res = await fetchWithTimeout(url, { method:"POST", body: formData }, UPLOAD_TIMEOUT_MS);
    }
    return res;
  }
  async function uploadSnapshotCanvas(canvas){
    try{
      setSleepPhotoStatus('Uploading...');
      const blob = await canvasToJpegBlobResized(canvas, 1600, 0.85);
      if(!blob){ setSleepPhotoStatus('Upload error'); return; }

      const res = await uploadBlob(blob);
      if(!res.ok){
        const txt = await res.text().catch(()=> "");
        setSleepPhotoStatus(`Upload failed: ${res.status}${txt ? " / " + txt.slice(0,80) : ""}`);
        return;
      }
      setSleepPhotoStatus('Uploaded');
      setTimeout(()=>setSleepPhotoStatus(''), 2600);
    }catch(err){
      console.error("UPLOAD ERROR RAW:", err);
      setSleepPhotoStatus('Upload error: ' + humanErr(err));
      setTimeout(()=>setSleepPhotoStatus(''), 5200);
    }
  }

  /* =========================
     Box detect assets
     ========================= */
  const LIMEN_LABELS = ["Mom","Hometown","Son Duk-Geum","GrandFather","Ocean"];
  const CLASS_TO_LIMEN = {
    person: "Mom",
    diningtable: "Hometown",
    bottle: "Ocean",
    cup: "Hometown",
    fork: "Son Duk-Geum",
    knife: "Son Duk-Geum",
    spoon: "Son Duk-Geum",
    chair: "GrandFather",
    tv: "Ocean",
    laptop: "Ocean",
    "cell phone": "Ocean"
  };
  function pickLimenLabelByClass(cocoClass, fallbackIndex){
    return CLASS_TO_LIMEN[cocoClass] || LIMEN_LABELS[fallbackIndex % LIMEN_LABELS.length];
  }
  function shuffleCopy(arr){
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  const ASSET_FILES = {
    "Mom": "assets/mom.jpg",
    "Hometown": "assets/hometown.jpg",
    "Son Duk-Geum": "assets/son-duk-geum.jpg",
    "GrandFather": "assets/grandfather.jpg",
    "Ocean": "assets/ocean.jpg"
  };

  const assets = new Map();
  async function loadAssets(){
    assets.clear();
    const entries = Object.entries(ASSET_FILES);
    for (const [label, path] of entries){
      const img = new Image();
      img.crossOrigin = "anonymous";
      const rec = { el:img, ready:false, path };
      assets.set(label, rec);
      await new Promise((res) => {
        img.onload = () => { rec.ready = true; res(); };
        img.onerror = () => { rec.ready = false; res(); };
        img.src = path + "?v=" + Date.now();
      });
    }
  }

  /* =========================
     coco-ssd model
     ========================= */
  let model=null;
  async function loadModel(){
    if(model) return model;
    model = await cocoSsd.load({ base:"lite_mobilenet_v2" });
    return model;
  }

  function iou(a,b){
    const ax1=a[0], ay1=a[1], ax2=a[0]+a[2], ay2=a[1]+a[3];
    const bx1=b[0], by1=b[1], bx2=b[0]+b[2], by2=b[1]+b[3];
    const ix1=Math.max(ax1,bx1), iy1=Math.max(ay1,by1);
    const ix2=Math.min(ax2,bx2), iy2=Math.min(ay2,by2);
    const iw=Math.max(0, ix2-ix1), ih=Math.max(0, iy2-iy1);
    const inter=iw*ih;
    const ua=a[2]*a[3] + b[2]*b[3] - inter;
    return ua>0 ? inter/ua : 0;
  }
  function makeLinks(points, k=2){
    const links=[];
    for(let i=0;i<points.length;i++){
      const ds=[];
      for(let j=0;j<points.length;j++){
        if(i===j) continue;
        const dx=points[i].x-points[j].x, dy=points[i].y-points[j].y;
        ds.push({j, d:dx*dx+dy*dy});
      }
      ds.sort((a,b)=>a.d-b.d);
      for(let t=0;t<Math.min(k, ds.length);t++){
        const j=ds[t].j;
        if(i<j) links.push([i,j,ds[t].d]);
      }
    }
    return links;
  }
  function scaleBox(bbox, s){
    const [x,y,w,h]=bbox;
    const cx = x + w/2, cy = y + h/2;
    const nw = w * s, nh = h * s;
    return [cx - nw/2, cy - nh/2, nw, nh];
  }

  function drawFragmentIntoBox(assetRec, bbox, seed, alphaMul=1){
    if (!assetRec || !assetRec.ready) return;
    const [x,y,w,h] = bbox;
    if (w < 8 || h < 8) return;

    const t = performance.now() * 0.001;
    const r1 = (Math.sin(seed*12.9898 + t*1.3) * 43758.5453) % 1;
    const r2 = (Math.sin(seed*78.233  + t*0.9) * 12345.6789) % 1;
    const r3 = (Math.sin(seed*41.77   + t*1.7) * 98765.4321) % 1;

    vctx.save();
    vctx.beginPath(); vctx.rect(x,y,w,h); vctx.clip();

    const scale = 1.05 + Math.abs(r1) * 1.25;
    const ox = (r2 - 0.5) * w * 0.35;
    const oy = (r3 - 0.5) * h * 0.35;

    const el = assetRec.el;
    const sw = el.naturalWidth||0;
    const sh = el.naturalHeight||0;
    if (sw < 2 || sh < 2){ vctx.restore(); return; }

    const dw = w * scale, dh = h * scale;
    const dx = x + (w - dw)/2 + ox;
    const dy = y + (h - dh)/2 + oy;

    vctx.globalAlpha = 0.85 * alphaMul;
    vctx.drawImage(el, dx, dy, dw, dh);

    vctx.globalAlpha = 0.32 * alphaMul;
    const dw2 = w * (0.85 + Math.abs(r2)*0.5);
    const dh2 = h * (0.85 + Math.abs(r3)*0.5);
    const dx2 = x + (w - dw2)/2 - ox*0.25;
    const dy2 = y + (h - dh2)/2 - oy*0.25;
    vctx.drawImage(el, dx2, dy2, dw2, dh2);

    vctx.restore();
    vctx.globalAlpha = 1;
  }

  // ✅ labels in white
  function drawLabelTag(label, cocoClass, x, y, alphaMul=1){
    const text = `${label} · ${cocoClass}`;
    vctx.font = `${Math.max(12, Math.round((view.clientWidth||innerWidth)/95))}px -apple-system, BlinkMacSystemFont, "SF Pro Text", "Apple SD Gothic Neo", "Noto Sans", Arial, sans-serif`;
    vctx.textBaseline = "top";
    const padX = 7, padY = 4;
    const tw = vctx.measureText(text).width;
    const th = Math.max(18, Math.round((view.clientWidth||innerWidth)/75));

    const ty = Math.max(0, y - th - 2);
    vctx.fillStyle = `rgba(0,0,0,${(0.60*alphaMul).toFixed(3)})`;
    vctx.fillRect(x, ty, tw + padX*2, th);

    vctx.fillStyle = `rgba(255,255,255,${(0.95*alphaMul).toFixed(3)})`;
    vctx.fillText(text, x + padX, ty + padY);
  }

  function computeMinAreaFromFine(fine, vw, vh){
    const base = vw * vh;
    const minRatio = 0.0015;
    const maxRatio = 0.12;
    const r = minRatio + (1 - fine) * (maxRatio - minRatio);
    return base * r;
  }

  let objectTracks = [];
  let renderTracks = [];
  let nextId = 1;

  function ensureDistinctLabelsForTopN(objs, nowMs){
    const holdMs = (+holdSecEl.value) * 1000;
    for (const o of objs){
      if (!o.label || nowMs > o.labelUntil) o.label = null;
    }
    const used = new Set(objs.filter(o=>o.label).map(o=>o.label));
    for (let i=0;i<objs.length;i++){
      const o = objs[i];
      if (!o.label){
        let candidate = pickLimenLabelByClass(o.cls, i);
        if (used.has(candidate)){
          const pool = shuffleCopy(LIMEN_LABELS).filter(L=>!used.has(L));
          if (pool.length) candidate = pool[0];
        }
        o.label = candidate;
        o.labelUntil = nowMs + holdMs;
        used.add(candidate);
      }
    }
  }

  const DETECT_INTERVAL_MS = 240;
  let lastDetectAt = 0;
  let runningDetect = false;

  async function stepDetect(){
    if(!model) await loadModel();
    if(!camVideo || camVideo.readyState < 2) return;

    const coarse = +confEl.value;
    const fine = +fineEl.value;
    confVal.textContent = coarse.toFixed(2);
    fineVal.textContent = fine.toFixed(2);

    let wantN = +topNEl.value;
    wantN = clamp(wantN, 3, 8);
    topNVal.textContent = String(wantN);

    holdValEl.textContent = (+holdSecEl.value).toFixed(1) + "s";

    const bs = clamp(+boxScaleEl.value, 0.35, 1.20);
    boxScaleValEl.textContent = bs.toFixed(2);

    const vw = camVideo.videoWidth || 0;
    const vh = camVideo.videoHeight || 0;
    const minArea = computeMinAreaFromFine(fine, vw||1280, vh||720);

    let preds = await model.detect(camVideo);

    preds = preds
      .filter(p => (p.score >= coarse) && ((p.bbox[2]*p.bbox[3]) >= minArea))
      .sort((a,b) => b.score - a.score);

    const candidates = preds.slice(0, 12);
    const nowMs = performance.now();

    const used = new Set();
    for (const tr of objectTracks){
      let bestJ = -1, bestI = 0;
      for (let j=0;j<candidates.length;j++){
        if (used.has(j)) continue;
        const s = iou(tr.bbox, candidates[j].bbox);
        if (s > bestI){ bestI=s; bestJ=j; }
      }
      if (bestJ >= 0 && bestI > 0.18){
        const p = candidates[bestJ];
        used.add(bestJ);
        tr.bbox = lerpBox(tr.bbox, p.bbox, 0.55);
        tr.cls = p.class;
        tr.score = p.score;
        tr.lastSeen = nowMs;
      }
    }

    for (let j=0;j<candidates.length;j++){
      if (used.has(j)) continue;
      const p = candidates[j];
      objectTracks.push({
        id: nextId++,
        bbox: p.bbox.slice(),
        cls: p.class,
        score: p.score,
        label: null,
        labelUntil: 0,
        lastSeen: nowMs,
        seed: (nextId*971 + j*37) >>> 0
      });
    }

    objectTracks = objectTracks.filter(tr => (nowMs - tr.lastSeen) < 1200);
    objectTracks.sort((a,b)=>b.score-a.score);
    renderTracks = objectTracks.slice(0, wantN);
    ensureDistinctLabelsForTopN(renderTracks, nowMs);
  }

  function mapVideoBoxToScreen(bbox, T){
    const [x,y,w,h] = bbox;
    const sx = T.dx + (x / T.vw) * T.dw;
    const sy = T.dy + (y / T.vh) * T.dh;
    const sw = (w / T.vw) * T.dw;
    const sh = (h / T.vh) * T.dh;
    return [sx, sy, sw, sh];
  }

  function drawCameraAndDetect(){
    const W = view.clientWidth || innerWidth;
    const H = view.clientHeight || innerHeight;

    vctx.save();
    vctx.fillStyle = '#000';
    vctx.fillRect(0,0,W,H);
    vctx.restore();

    const T = getCameraDrawTransform();
    if(showCamera && T){
      vctx.save();
      vctx.globalAlpha = camFadeAlpha;
      vctx.drawImage(camVideo, T.dx, T.dy, T.dw, T.dh);
      vctx.restore();

      const alphaMul = camFadeAlpha;
      const boxScale = clamp(+boxScaleEl.value, 0.35, 1.20);

      // ✅ links: pure white
      if (linksEl.checked && renderTracks.length >= 2){
        const screenBoxes = renderTracks.map(tr => mapVideoBoxToScreen(tr.bbox, T));
        const scaledBoxes = screenBoxes.map(b => scaleBox(b, boxScale));
        const pts = scaledBoxes.map(b => ({x:b[0]+b[2]/2, y:b[1]+b[3]/2}));
        const links = makeLinks(pts, 2);

        for (const [i,j,dd] of links){
          const a = pts[i], b = pts[j];
          const dist = Math.sqrt(dd);
          const norm = Math.min(1, dist / Math.max(W, H));
          const alpha = clamp((0.62*(1-norm) + 0.10), 0.05, 0.92) * alphaMul;

          vctx.save();
          vctx.strokeStyle = `rgba(255,255,255,${alpha.toFixed(3)})`;
          vctx.lineWidth = Math.max(1.1, W/1150);
          vctx.beginPath();
          vctx.moveTo(a.x, a.y);
          vctx.lineTo(b.x, b.y);
          vctx.stroke();
          vctx.restore();
        }
      }

      vctx.lineWidth = Math.max(2, W/980);

      for (let idx=0; idx<renderTracks.length; idx++){
        const tr = renderTracks[idx];
        const label = tr.label || "—";

        const screenBox = mapVideoBoxToScreen(tr.bbox, T);
        const b = scaleBox(screenBox, boxScale);
        const [x,y,w,h] = b;

        if (fillFragEl.checked){
          const asset = assets.get(label);
          drawFragmentIntoBox(asset, b, (tr.seed + idx*77) >>> 0, alphaMul);
        }

        vctx.save();
        vctx.globalAlpha = alphaMul;
        vctx.strokeStyle = `rgba(255,255,255,0.95)`;
        vctx.strokeRect(x,y,w,h);
        vctx.restore();

        drawLabelTag(label, tr.cls, x, y, alphaMul);
      }

      countEl.textContent = "Boxes " + renderTracks.length;
    }
  }

  let lastT = performance.now();
  let emaFps = 0;

  async function tick(){
    if(!runningDetect) return;

    const now = performance.now();
    if ((now - lastDetectAt) > DETECT_INTERVAL_MS){
      lastDetectAt = now;
      try{ await stepDetect(); }
      catch(e){ log("DETECT ERROR: " + (e?.message || e)); }
    }

    const dt = (now - lastT) / 1000;
    lastT = now;
    const inst = dt>0 ? (1/dt) : 0;
    emaFps = emaFps ? (emaFps*0.9 + inst*0.1) : inst;

    log(`FPS ${emaFps.toFixed(1)}   |   Boxes ${renderTracks.length}`);
    requestAnimationFrame(tick);
  }

  function renderLoop(){
    drawCameraAndDetect();
    requestAnimationFrame(renderLoop);
  }
  requestAnimationFrame(renderLoop);

  /* =========================
     CAPTURE
     ========================= */
  let capturing=false;
  async function captureCurrentView(){
    if(capturing) return;
    capturing = true;
    try{
      setSleepPhotoStatus('Capturing...');
      const w = view.width;
      const h = view.height;

      freezeLayer.width = w;
      freezeLayer.height = h;

      const ctx = freezeLayer.getContext('2d');
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,w,h);
      ctx.drawImage(view, 0,0, w, h);

      await uploadSnapshotCanvas(freezeLayer);
    }catch(e){
      setSleepPhotoStatus('Capture error');
      setTimeout(()=>setSleepPhotoStatus(''), 5000);
    }finally{
      freezeLayer.style.display = 'none';
      capturing = false;
    }
  }

  captureBtn.addEventListener('click', async (e)=>{
    e.preventDefault();
    await ensureResumed();
    playClick();
    captureCurrentView();
  }, {passive:false});

  /* =========================
     UI actions
     ========================= */
  flipBtn.addEventListener('click', async ()=>{
    try{
      facingMode = (facingMode === "environment") ? "user" : "environment";
      if(!usingUploadVideo){
        await startCameraFresh();
        fadeInCamera(FADE_MS);
      }
      playClick();
    }catch(e){
      log("flip error");
    }
  }, {passive:true});

  restartBtn.addEventListener('click', ()=>{
    objectTracks = [];
    renderTracks = [];
    lastDetectAt = 0;
    playClick();
  }, {passive:true});

  useCamBtn.addEventListener('click', async ()=>{
    try{
      await startCameraFresh();
      fadeInCamera(FADE_MS);
      objectTracks = [];
      renderTracks = [];
      playClick();
    }catch(e){
      log("camera error");
    }
  }, {passive:true});

  videoFileEl.addEventListener('change', async ()=>{
    const file = videoFileEl.files?.[0];
    if(!file) return;
    try{
      await useUploadedVideo(file);
      fadeInCamera(FADE_MS);
      objectTracks = [];
      renderTracks = [];
      playClick();
    }catch(e){
      log("upload error");
    }
  }, {passive:true});

  /* =========================
     ✅ FLOW: intro -> allow camera -> wait -> tap to join -> camera view
     ========================= */
  // Steps:
  // 0: welcome + tap to allow camera
  // 1: camera allowed (or attempted) -> show "Please open the camera. The performance will begin shortly."
  // 2: show "Tap anywhere to join the program." (tap starts camera + detection + fades intro)

  let stage = 0;
  let joined = false;

  // start values
  boxScaleEl.value = "0.40";
  boxScaleValEl.textContent = "0.40";

  async function warmUp(){
    try{
      await loadModel();
      await loadAssets();
    }catch(e){
      log("warmup error");
    }
  }

  function setIntroText(title, sub){
    introTitle.textContent = title || '';
    introSub.textContent = sub || '';
  }

  function fadeOutIntro(){
    intro.classList.add('hidden');
    setTimeout(()=>{ intro.style.display = 'none'; }, Math.round(FADE_MS));
  }

  async function requestCameraPermissionOnly(){
    try{
      const s = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:{ideal:facingMode} },
        audio:false
      });
      s.getTracks().forEach(t=>t.stop());
      return true;
    }catch(e){
      return false;
    }
  }

  async function joinProgram(){
    if(joined) return;
    joined = true;

    fadeOutIntro();

    // show controls
    controls.classList.add('show');
    captureBtn.classList.add('show');

    // start actual camera + fade in camera
    try{
      await startCameraFresh();
      fadeInCamera(FADE_MS);
    }catch(e){
      log("camera start failed");
    }

    // start detection loop
    runningDetect = true;
    lastT = performance.now();
    lastDetectAt = 0;
    tick();
  }

  async function onIntroTap(e){
    if(e && e.preventDefault) e.preventDefault();

    await ensureResumed();
    playClick();

    if(stage === 0){
      // Ask for camera permission (iOS requirement)
      const ok = await requestCameraPermissionOnly(); // even if false, proceed to next stage
      await warmUp();

      // After allowing camera (or attempting), show "performance will begin shortly" and "open the camera"
      setIntroText(
        "Welcome. Thank you for participating in the program.",
        "Please open the camera. The performance will begin shortly."
      );

      stage = 1;

      // after a moment, prompt user to join (tap)
      setTimeout(()=>{
        if(stage !== 1 || joined) return;
        setIntroText(
          "Welcome. Thank you for participating in the program.",
          "Tap anywhere to join the program."
        );
        stage = 2;
      }, 1800);

      return;
    }

    if(stage === 1){
      // if user taps early, just fast-forward to join prompt
      setIntroText(
        "Welcome. Thank you for participating in the program.",
        "Tap anywhere to join the program."
      );
      stage = 2;
      return;
    }

    if(stage === 2){
      // join
      await joinProgram();
      return;
    }
  }

  // Intro overlay handles taps
  ['click','touchstart','pointerdown'].forEach(type=>{
    intro.addEventListener(type, onIntroTap, {passive:false});
  });

})();
</script>
</body>
</html>
