<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>History of Nightmare — Fill without lines</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  /* 카메라(흑백) */
  #view{position:fixed;inset:0;width:100%;height:100%;display:block;z-index:0}

  /* ── 오버레이 래퍼(여기에 투명도 0.5 적용) ── */
  #overlayWrap{
    position:fixed; inset:0; z-index:10;
    pointer-events:none;
    opacity:0;                     /* OUT 상태 */
    transition:opacity .35s ease;
    background:#000;               /* contain 모드에서 생기는 여백도 같은 투명도로 어둡게 */
  }
  /* 실제 VDO.Ninja iframe (불투명 1.0로 두고 래퍼에서 블렌딩) */
  #ninjaOverlay{
    position:absolute; left:50%; top:50%;
    transform:translate(-50%,-50%);
    border:0; pointer-events:none;
  }

  /* IN/OUT 두 버튼 */
  .controls{position:fixed; right:20px; bottom:20px; z-index:100; display:flex; gap:8px}
  .uiBtn{background:#000;color:#fff;border:1px solid #333;font-family:"Courier New",monospace;
         padding:.6em 1.2em;cursor:pointer;user-select:none}

  /* 웰컴 오버레이 */
  #overlay{
    position:fixed; inset:0; z-index:200; display:flex; align-items:center; justify-content:center;
    padding:20px; font-family:"Courier New",monospace; color:#fff; background:rgba(0,0,0,.7);
  }
  #overlayContent{line-height:1.7; text-align:center; transition:opacity .45s ease}
  .hidden{opacity:0}
</style>
</head>
<body>
  <canvas id="view"></canvas>

  <!-- 레졸룸(VDO.Ninja) 오버레이(래퍼에 opacity=0.5 적용) -->
  <div id="overlayWrap">
    <iframe id="ninjaOverlay"
            allow="autoplay; fullscreen; camera; microphone; clipboard-read; clipboard-write"
            referrerpolicy="no-referrer"
            src="about:blank"></iframe>
  </div>

  <div class="controls">
    <button class="uiBtn" id="btnIn">IN</button>
    <button class="uiBtn" id="btnOut">OUT</button>
  </div>

  <div id="overlay">
    <div id="overlayContent">
      <button id="welcomeBtn" class="uiBtn">Welcome to History of Nightmare</button>
      <div style="opacity:.75;margin-top:8px;font-size:12px">버튼을 누르면 카메라/마이크/센서 권한을 요청합니다. iPhone은 <b>HTTPS</b> 권장.</div>
    </div>
  </div>

<script>
(()=> {
/* ===== 옵션 ===== */
const ROOM_ID = "YOURROOMID";
/* FILL_MODE: 'stretch' | 'contain' | 'cover'
   - stretch : 화면 꽉 채우되 비율 무시(왜곡 가능, 라인 없음)
   - contain : 비율 유지, 전체 보임(여백은 overlayWrap의 반투명 검정으로 처리 → 라인 느낌 최소화)
   - cover   : 비율 유지, 화면 꽉 채움(일부 크롭) */
const FILL_MODE = 'stretch';

const base = `https://vdo.ninja/?view=${encodeURIComponent(ROOM_ID)}&clean&autostart&noaudio&codec=vp8&solo`;
const ninjaUrl = () => `${base}&ts=${Date.now()}`;

/* ===== 요소 ===== */
const view = document.getElementById('view');
const vctx = view.getContext('2d', {alpha:false});
const wrap = document.getElementById('overlayWrap');
const ninja = document.getElementById('ninjaOverlay');
const btnIn = document.getElementById('btnIn');
const btnOut = document.getElementById('btnOut');
const overlayPanel = document.getElementById('overlay');
const overlayContent = document.getElementById('overlayContent');

/* ===== 카메라(흑백) ===== */
const cam = document.createElement('video');
cam.autoplay=true; cam.muted=true; cam.playsInline=true;

const proc = document.createElement('canvas');
const pctx = proc.getContext('2d',{willReadFrequently:true});
const PROC_SCALE=0.60;

function fitCamera(){
  const dpr=devicePixelRatio||1;
  view.width=innerWidth*dpr; view.height=innerHeight*dpr;
  vctx.setTransform(dpr,0,0,dpr,0,0);
  const scale=matchMedia('(orientation:landscape)').matches? PROC_SCALE*0.9 : PROC_SCALE;
  proc.width=Math.floor(innerWidth*scale);
  proc.height=Math.floor(innerHeight*scale);
}

async function startCamera(){
  const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
  cam.srcObject=s; await cam.play().catch(()=>{});
}

let _loop=false;
function ensureLoop(){ if(_loop) return; _loop=true; loop(); }
function loop(){
  requestAnimationFrame(loop);
  const W=view.width/(devicePixelRatio||1), H=view.height/(devicePixelRatio||1);
  const PW=proc.width, PH=proc.height;
  pctx.clearRect(0,0,PW,PH);
  if(cam.readyState>=2){
    const vw=cam.videoWidth, vh=cam.videoHeight;
    if(vw&&vh){
      const sc=Math.max(PW/vw,PH/vh);
      const dw=vw*sc, dh=vh*sc, dx=(PW-dw)/2, dy=(PH-dh)/2;
      pctx.drawImage(cam,dx,dy,dw,dh);
      const img=pctx.getImageData(0,0,PW,PH), d=img.data;
      for(let i=0;i<d.length;i+=4){ const g=(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2])|0; d[i]=d[i+1]=d[i+2]=g; }
      pctx.putImageData(img,0,0);
    }
  }
  vctx.clearRect(0,0,W,H);
  vctx.drawImage(proc,0,0,W,H);
}

/* ===== 오디오/센서(마이크 + 기울기→팬/볼륨) ===== */
let audioCtx=null, mixBus=null, motionGain=null, masterGain=null, panSetter=null, micStream=null;
function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  mixBus = audioCtx.createGain();
  if(audioCtx.createStereoPanner){
    const sp=audioCtx.createStereoPanner();
    panSetter=(v)=>{ try{ sp.pan.setTargetAtTime(v,audioCtx.currentTime,0.08);}catch{ sp.pan.value=v; } };
    mixBus.connect(sp).connect(audioCtx.destination);
  }else{
    const l=audioCtx.createGain(), r=audioCtx.createGain(), m=audioCtx.createChannelMerger(2);
    mixBus.connect(l); mixBus.connect(r); l.connect(m,0,0); r.connect(m,0,1); m.connect(audioCtx.destination);
    panSetter=(p)=>{ const x=Math.max(-1,Math.min(1,p||0)); const th=(x+1)*0.25*Math.PI;
      l.gain.value=Math.cos(th); r.gain.value=Math.sin(th); };
  }
  motionGain = audioCtx.createGain(); motionGain.gain.value=0.2;
  masterGain = audioCtx.createGain(); masterGain.gain.value=1.0;
  mixBus.connect(motionGain).connect(masterGain);
}
async function startMic(){
  if(micStream) return;
  const s=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:false,noiseSuppression:true,autoGainControl:false},video:false});
  micStream=s; const src=audioCtx.createMediaStreamSource(s);
  const hpf=audioCtx.createBiquadFilter(); hpf.type='highpass'; hpf.frequency.value=220;
  const notch=audioCtx.createBiquadFilter(); notch.type='notch'; notch.frequency.value=300; notch.Q.value=3.5;
  const comp=audioCtx.createDynamicsCompressor(); comp.threshold.value=-20; comp.ratio.value=3.5; comp.attack.value=0.006; comp.release.value=0.12;
  const wet=audioCtx.createGain(); wet.gain.value=0.55; const dry=audioCtx.createGain(); dry.gain.value=0.08;
  const convolver=audioCtx.createConvolver(); convolver.buffer=makeIR(2.6,2.4);
  src.connect(hpf).connect(notch).connect(comp);
  const split=audioCtx.createGain(); comp.connect(split);
  split.connect(dry); split.connect(convolver).connect(wet);
  const bus=audioCtx.createGain(); dry.connect(bus); wet.connect(bus);
  bus.connect(motionGain);
}
function makeIR(sec=2.6,decay=2.4){
  const rate=audioCtx.sampleRate, len=Math.floor(rate*sec), ir=audioCtx.createBuffer(2,len,rate);
  for(let c=0;c<2;c++){ const v=ir.getChannelData(c); for(let i=0;i<len;i++){ const t=i/len, env=Math.pow(1-t,decay); v[i]=(Math.random()*2-1)*env*0.55; } }
  return ir;
}
let sensorsReady=false, latestOri={beta:0,gamma:0}, smVol=0.2, smPan=0;
function sensorPerm(){ try{ if(DeviceOrientationEvent?.requestPermission) DeviceOrientationEvent.requestPermission().then(r=>{if(r==='granted')sensorsReady=true;}); else sensorsReady=true;}catch{} }
function initOrientation(){ addEventListener('deviceorientation',(e)=>{latestOri.beta=e.beta??0; latestOri.gamma=e.gamma??0;},{passive:true}); }
function smooth(t,c,a=0.12){ return c+(t-c)*a; }
function ctlLoop(){
  requestAnimationFrame(ctlLoop);
  let pan=0, vol=0.2;
  if(sensorsReady){
    const angle=(screen.orientation?.angle)||0;
    const beta=latestOri.beta||0, gamma=latestOri.gamma||0;
    const panTilt = (angle%180===0)? gamma : beta;
    const volTilt = (angle%180===0)? beta  : -gamma;
    pan = Math.max(-1,Math.min(1, (Math.abs(panTilt)<3?0:panTilt/45)));
    const a = Math.max(0,(Math.abs(volTilt)-5)/(60-5)); vol = 0.2 + 0.55*a;
  }
  smPan=smooth(pan,smPan); smVol=smooth(vol,smVol);
  if(panSetter) panSetter(smPan);
  if(motionGain){ const now=audioCtx.currentTime; try{ motionGain.gain.setTargetAtTime(smVol,now,0.08);}catch{ motionGain.gain.value=smVol; } }
}

/* ===== 오버레이 꽉 채우기 ===== */
function sizeOverlay(){
  const W=innerWidth, H=innerHeight;
  if (FILL_MODE==='stretch'){                  // 왜곡 허용, 라인 없음
    ninja.style.width = W+'px';
    ninja.style.height = H+'px';
  } else if (FILL_MODE==='contain'){           // 비율 유지, 전체 보임(여백은 반투명 검정)
    const AR = 16/9;                           // 필요하면 실제 영상 비율로 조정
    const winAR = W/H;
    let w,h;
    if (winAR > AR){ h=H; w=h*AR; } else { w=W; h=w/AR; }
    ninja.style.width = w+'px';
    ninja.style.height = h+'px';
  } else {                                     // cover: 일부 크롭
    const AR = 16/9;
    const winAR = W/H;
    let w,h;
    if (winAR > AR){ w=W; h=w/AR; } else { h=H; w=h*AR; }
    ninja.style.width = w+'px';
    ninja.style.height = h+'px';
  }
}
addEventListener('resize', sizeOverlay);

/* ===== 프리로드 / IN-OUT ===== */
(function preload(){
  ninja.src = ninjaUrl();      // 연결 유지
  sizeOverlay();
})();
function setOverlay(on){
  wrap.style.opacity = on ? '0.5' : '0';  // 50% 블렌딩은 래퍼에 적용(라인 방지)
  if(on && !ninja.contentWindow) ninja.src = ninjaUrl();
}
btnIn.addEventListener('click', ()=> setOverlay(true));
btnOut.addEventListener('click', ()=> setOverlay(false));

/* ===== 웰컴 버튼 ===== */
document.getElementById('welcomeBtn').addEventListener('click', async ()=>{
  try{
    sensorPerm(); initAudio(); if(audioCtx.state==='suspended'){ await audioCtx.resume().catch(()=>{}); }
    await startMic().catch(()=>{});
    initOrientation(); ctlLoop();
    await startCamera(); fitCamera(); ensureLoop();
    overlayContent.classList.add('hidden'); setTimeout(()=>{ overlayPanel.style.display='none'; }, 450);
    setOverlay(true);
  }catch(e){
    overlayContent.innerHTML='<div style="background:#000;padding:10px;display:inline-block">권한을 허용해 주세요.</div>';
  }
});
document.addEventListener('visibilitychange', ()=>{ if(audioCtx && audioCtx.state==='suspended') audioCtx.resume().catch(()=>{}); });

})();
</script>
</body>
</html>
