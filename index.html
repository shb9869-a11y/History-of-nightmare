<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,interactive-widget=resizes-content">
<title>From Emptiness (空) to Togetherness (共)</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="EMPTINESS→TOGETHERNESS">
<meta name="theme-color" content="#000000">

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>

<style>
:root{
  --frame: clamp(16px, 4vmin, 40px);
  --ui-gap: 8px;
  --fs-strong: clamp(14px, 2.8vmin, 18px);
  --fs-small: clamp(11px, 1.8vmin, 13px);
  --safe-t: env(safe-area-inset-top, 0px);
  --safe-b: env(safe-area-inset-bottom, 0px);
  --safe-l: env(safe-area-inset-left, 0px);
  --safe-r: env(safe-area-inset-right, 0px);

  --ink: #c9cfab;
  --ink-dim: rgba(201,207,171,.78);
  --red: #b3342b;
  --white: #f5f5f5;
}

html,body{
  margin:0; padding:0; width:100%; height:100%;
  background:#000; overflow:hidden;
  touch-action: manipulation;
}
body{
  font-family: ui-serif, "Iowan Old Style", "Palatino Linotype", Palatino, "Times New Roman", Times, serif;
  -webkit-user-select:none; user-select:none;
  -webkit-touch-callout:none;
  color:var(--ink);
}
*{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }

.fade{opacity:0; transition:opacity 900ms ease}
.fade.show{opacity:1}

/* ✅ 모자이크 배경 */
#bg{
  position:fixed; inset:0;
  width:100vw; height:100vh;
  z-index:0;
  display:block;
  background:#000;
}

/* 카메라/트래킹 캔버스 */
#view{
  position:fixed; inset:0;
  width:100vw; height:100vh;
  z-index:1;
  display:block;
  filter:grayscale(1);
  opacity:0;
  pointer-events:none;
  transition:opacity 900ms ease;
}
#view.show{opacity:1;}

.frameBox{
  position:fixed;
  left:calc(var(--frame) + var(--safe-l));
  top:calc(var(--frame) + var(--safe-t));
  right:calc(var(--frame) + var(--safe-r));
  bottom:calc(var(--frame) + var(--safe-b));
  border:2px solid rgba(245,245,245,.65);
  pointer-events:none;
  z-index:50;
}

/* ======= HELP ======= */
#helpBtn{
  position:fixed;
  left:calc(var(--frame) + var(--ui-gap) + var(--safe-l));
  top:calc(var(--frame) + var(--ui-gap) + var(--safe-t));
  z-index:930;
  border:1px solid rgba(255,255,255,.14);
  border-radius:14px;
  background:rgba(0,0,0,.22);
  backdrop-filter: blur(10px);
  color:rgba(245,245,245,.92);
  padding:8px 12px;
  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  letter-spacing:.18em;
  font-size:12px;
  opacity:.9;
}
#helpPanel{
  position:fixed; inset:0;
  z-index:940;
  display:none;
  background:rgba(0,0,0,.72);
  backdrop-filter: blur(12px);
}
#helpPanel.show{display:block;}
#helpPanel .box{
  position:absolute;
  left:calc(var(--frame) + var(--safe-l));
  right:calc(var(--frame) + var(--safe-r));
  top:calc(var(--frame) + 56px + var(--safe-t));
  max-width:920px;
  margin:0 auto;
  border:1px solid rgba(255,255,255,.14);
  border-radius:18px;
  background:rgba(0,0,0,.55);
  padding:16px 16px 18px 16px;
  color:var(--ink);
  line-height:1.55;
}
#helpPanel .close{
  position:absolute;
  right:calc(var(--frame) + var(--ui-gap) + var(--safe-r));
  top:calc(var(--frame) + var(--ui-gap) + var(--safe-t));
  z-index:941;
  border:none;
  background:transparent;
  color:#fff;
  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  letter-spacing:.18em;
  font-size:12px;
  opacity:.9;
  padding:10px 12px;
}

/* ======= 인트로/안내 스테이지 ======= */
#stage{
  position:fixed; inset:0;
  z-index:300;
  background: radial-gradient(1200px 700px at 50% 55%, rgba(255,255,255,.06), rgba(0,0,0,.92) 65%, rgba(0,0,0,.98));
}
#stage.hidden{ opacity:0; pointer-events:none; transition:opacity 900ms ease; }

/* ✅ 탭 레이어를 최상단으로 + 텍스트는 클릭을 먹지 않게 */
#stageTap{
  position:absolute; inset:0;
  z-index:999;
  cursor:pointer;
}
.stageBlock{
  position:absolute;
  max-width:min(88vw, 980px);
  line-height:1.55;
  letter-spacing:.01em;
  text-shadow:0 0 10px rgba(0,0,0,.35);
  pointer-events:none; /* ✅ 이게 핵심 */
  z-index:10;
}
.stageTitle{
  font-size:clamp(22px, 4.4vmin, 54px);
  margin:0 0 10px 0;
  color:var(--ink);
}
.stageSub{
  font-size:clamp(14px, 2.2vmin, 20px);
  color:var(--ink-dim);
  margin:0;
}
.pos-top-right{
  top:calc(var(--frame) + 10px + var(--safe-t));
  right:calc(var(--frame) + 10px + var(--safe-r));
  text-align:left;
}
.pos-bottom-left{
  left:calc(var(--frame) + 10px + var(--safe-l));
  bottom:calc(var(--frame) + 62px + var(--safe-b));
  text-align:left;
}
.pos-center{
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  text-align:center;
}
.stageLines{
  font-size:clamp(16px, 2.8vmin, 28px);
  color:var(--ink);
  white-space:pre-wrap;
}
.stageLines.small{ font-size:clamp(14px, 2.2vmin, 20px); }

.line{
  opacity:0;
  transform: translateY(6px);
  transition: opacity 700ms ease, transform 700ms ease;
}
.line.show{ opacity:1; transform: translateY(0px); }

.tapHint{
  position:absolute;
  left:50%;
  bottom:calc(var(--frame) + 14px + var(--safe-b));
  transform:translateX(-50%);
  font-size:clamp(12px, 2.0vmin, 16px);
  letter-spacing:.08em;
  color:rgba(179,52,43,.92);
  text-shadow:0 0 12px rgba(0,0,0,.55);
  opacity:.95;
  pointer-events:none;
  z-index:20;
}
#countdown{
  position:absolute;
  left:50%; top:50%;
  transform:translate(-50%,-50%);
  font-size:clamp(42px, 9vmin, 92px);
  color:var(--ink);
  letter-spacing:.02em;
  opacity:0;
  transition:opacity 400ms ease;
  pointer-events:none;
  z-index:20;
}
#countdown.show{opacity:1}

/* 아래 버튼/메뉴는 일단 유지(너가 이미 쓰던 기능 때문에) */
#toggleUI{ display:none; } /* ✅ PPT 톤 유지하려면 우선 숨김 */
#ui{ display:none; }
.controls{ display:none; }
.btn-capture{ display:none; }
.sleep-status-text{ display:none; }

</style>
</head>

<body>
  <canvas id="bg"></canvas>
  <canvas id="view"></canvas>
  <div class="frameBox" aria-hidden="true"></div>

  <button id="helpBtn" aria-label="help">HELP</button>
  <div id="helpPanel" aria-hidden="true">
    <button class="close" id="helpClose" aria-label="close help">CLOSE</button>
    <div class="box">
      <div style="font-size:clamp(18px,2.8vmin,26px); margin-bottom:10px; color:var(--ink);">
        HELP
      </div>
      <div style="color:var(--ink); font-size:clamp(13px,2.1vmin,18px); white-space:pre-wrap;">
This program unfolds through taking photos.
Each performance has its own interpretation and participation method.
Press HELP anytime.
      </div>
    </div>
  </div>

  <div id="stage" class="fade show">
    <div id="stageTap" aria-label="tap to continue"></div>

    <div id="blkTitle" class="stageBlock pos-center" style="display:none;">
      <h1 class="stageTitle">From Emptiness (空) to Togetherness (共)</h1>
      <p class="stageSub">A Cooking–Memory–Spatial Experiment in Reconstructing Empathy</p>
    </div>

    <div id="blkTR" class="stageBlock pos-top-right" style="display:none;">
      <div id="linesTR" class="stageLines small"></div>
    </div>

    <div id="blkBL" class="stageBlock pos-bottom-left" style="display:none;">
      <div id="linesBL" class="stageLines small"></div>
    </div>

    <div id="blkCenter" class="stageBlock pos-center" style="display:none;">
      <div id="linesCenter" class="stageLines"></div>
    </div>

    <div id="countdown">10</div>
    <div id="tapHint" class="tapHint">TAP ANYWHERE TO CONTINUE</div>
  </div>

<script>
(() => {
  const qs = s => document.querySelector(s);
  const sleep = ms => new Promise(r=>setTimeout(r,ms));

  /* =========================
     ✅ PPT 레퍼런스: 모자이크 배경
     - mosaic/ 폴더에 이미지 넣으면 그걸로 구성
     ========================= */
  const bg = qs('#bg');
  const bctx = bg.getContext('2d', { alpha:false });

  const MOSAIC_IMAGES = [
    // ✅ 여기 파일명만 맞춰서 넣으면 됨 (원하면 개수 늘려도 OK)
    "mosaic/01.jpg","mosaic/02.jpg","mosaic/03.jpg","mosaic/04.jpg","mosaic/05.jpg","mosaic/06.jpg",
    "mosaic/07.jpg","mosaic/08.jpg","mosaic/09.jpg","mosaic/10.jpg","mosaic/11.jpg","mosaic/12.jpg",
    "mosaic/13.jpg","mosaic/14.jpg","mosaic/15.jpg","mosaic/16.jpg","mosaic/17.jpg","mosaic/18.jpg",
    "mosaic/19.jpg","mosaic/20.jpg","mosaic/21.jpg","mosaic/22.jpg","mosaic/23.jpg","mosaic/24.jpg",
    "mosaic/25.jpg","mosaic/26.jpg","mosaic/27.jpg","mosaic/28.jpg","mosaic/29.jpg","mosaic/30.jpg",
  ];

  let BW = 0, BH = 0, DPR = 1;

  function resizeBG(){
    DPR = window.devicePixelRatio || 1;
    BW = innerWidth; BH = innerHeight;
    bg.width = Math.round(BW * DPR);
    bg.height = Math.round(BH * DPR);
    bctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', resizeBG, {passive:true});
  addEventListener('orientationchange', resizeBG, {passive:true});
  resizeBG();

  // 이미지 프리로드
  const mosaicPool = [];
  async function loadMosaic(){
    mosaicPool.length = 0;
    for(const src of MOSAIC_IMAGES){
      const img = new Image();
      img.crossOrigin = "anonymous";
      const ok = await new Promise(res=>{
        img.onload = ()=>res(true);
        img.onerror = ()=>res(false);
        img.src = src + "?v=" + Date.now();
      });
      if(ok) mosaicPool.push(img);
    }
  }
  loadMosaic(); // 실패해도 아래 더미 타일로 동작

  // 타일 월 구성
  let tiles = [];
  function rebuildTiles(){
    tiles = [];
    const cols = Math.max(10, Math.round(BW / 110));    // PPT처럼 촘촘한 느낌
    const rows = Math.max(6, Math.round(BH / 90));
    const tw = BW / cols;
    const th = BH / rows;

    let idx = 0;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        // 일부는 빈칸(검정)로 두는 느낌
        const empty = Math.random() < 0.18;

        tiles.push({
          r,c,
          x: c*tw,
          y: r*th,
          w: tw,
          h: th,
          imgIndex: idx++ % Math.max(1, mosaicPool.length),
          empty,
          jitterSeed: Math.random()*1000,
          swapAt: performance.now() + 1500 + Math.random()*6000,
          alpha: 1
        });
      }
    }
  }
  rebuildTiles();
  addEventListener('resize', rebuildTiles, {passive:true});

  function drawTileImage(img, x,y,w,h){
    // cover draw
    const iw = img.naturalWidth, ih = img.naturalHeight;
    if(!iw || !ih) return false;
    const ir = iw/ih;
    const tr = w/h;
    let sx=0, sy=0, sw=iw, sh=ih;
    if(ir > tr){
      sh = ih;
      sw = ih*tr;
      sx = (iw - sw)/2;
    }else{
      sw = iw;
      sh = iw/tr;
      sy = (ih - sh)/2;
    }
    bctx.drawImage(img, sx,sy,sw,sh, x,y,w,h);
    return true;
  }

  function bgLoop(tms){
    const t = tms*0.001;

    bctx.fillStyle = "#000";
    bctx.fillRect(0,0,BW,BH);

    // 전체 월이 천천히 “흐르는” 느낌(별자리X)
    const driftX = Math.sin(t*0.07)*18 + t*6;   // 아주 느린 가로 이동
    const driftY = Math.cos(t*0.05)*10;

    // vignette
    const g = bctx.createRadialGradient(BW*0.5,BH*0.55, 10, BW*0.5,BH*0.55, Math.max(BW,BH)*0.85);
    g.addColorStop(0, 'rgba(255,255,255,0.04)');
    g.addColorStop(0.55,'rgba(0,0,0,0.72)');
    g.addColorStop(1, 'rgba(0,0,0,0.96)');
    bctx.fillStyle = g;
    bctx.fillRect(0,0,BW,BH);

    // 타일 그리기
    const hasImgs = mosaicPool.length > 0;
    for(const tile of tiles){
      // swap 타이밍에 이미지 교체 + 페이드
      if(hasImgs && tms > tile.swapAt){
        tile.swapAt = tms + 2500 + Math.random()*7000;
        tile.imgIndex = (tile.imgIndex + 1 + (Math.random()*7|0)) % mosaicPool.length;
        tile.alpha = 0;
        tile.empty = (Math.random() < 0.18);
      }
      tile.alpha = Math.min(1, tile.alpha + 0.02);

      const jx = Math.sin(t*0.8 + tile.jitterSeed) * 1.6;
      const jy = Math.cos(t*0.7 + tile.jitterSeed) * 1.2;

      const x = tile.x + ((driftX % tile.w) - tile.w) + jx;
      const y = tile.y + driftY + jy;
      const w = tile.w+0.5, h = tile.h+0.5;

      // wrap
      let xx = x;
      while(xx < -tile.w) xx += BW + tile.w;
      while(xx > BW) xx -= BW + tile.w;

      bctx.save();
      bctx.globalAlpha = 0.92 * tile.alpha;

      if(tile.empty || !hasImgs){
        // 더미 타일(이미지 없을 때도 “영상 조각”처럼)
        const lum = 18 + (Math.sin(t*0.9 + tile.jitterSeed)*0.5+0.5)*42;
        bctx.fillStyle = `rgb(${lum|0},${lum|0},${lum|0})`;
        bctx.fillRect(xx,y,w,h);
      }else{
        const img = mosaicPool[tile.imgIndex];
        if(img) drawTileImage(img, xx,y,w,h);
        // 흑백 + 약간의 컨트라스트 느낌(캔버스에서 간단히)
        bctx.fillStyle = "rgba(0,0,0,0.18)";
        bctx.fillRect(xx,y,w,h);
      }

      // 타일 사이 약간의 간격/라인
      bctx.globalAlpha = 0.18;
      bctx.strokeStyle = "rgba(0,0,0,0.7)";
      bctx.lineWidth = 1;
      bctx.strokeRect(xx+0.5,y+0.5,w-1,h-1);

      bctx.restore();
    }

    requestAnimationFrame(bgLoop);
  }
  requestAnimationFrame(bgLoop);

  /* =========================
     ✅ 인트로 탭 동작
     ========================= */
  const stage = qs('#stage');
  const stageTap = qs('#stageTap');
  const tapHint = qs('#tapHint');
  const blkTitle = qs('#blkTitle');
  const blkTR = qs('#blkTR');
  const blkBL = qs('#blkBL');
  const blkCenter = qs('#blkCenter');
  const linesTR = qs('#linesTR');
  const linesBL = qs('#linesBL');
  const linesCenter = qs('#linesCenter');
  const countdownEl = qs('#countdown');

  function mountLines(el, lines){
    el.innerHTML = "";
    const nodes = [];
    for(const s of lines){
      const div = document.createElement("div");
      div.className = "line";
      div.textContent = s === "" ? " " : s;
      el.appendChild(div);
      nodes.push(div);
    }
    return nodes;
  }
  function showLine(nodes, i){ if(nodes[i]) nodes[i].classList.add("show"); }

  function clearBlocks(){
    blkTitle.style.display="none";
    blkTR.style.display="none";
    blkBL.style.display="none";
    blkCenter.style.display="none";
    linesTR.innerHTML=""; linesBL.innerHTML=""; linesCenter.innerHTML="";
    countdownEl.classList.remove("show");
    countdownEl.textContent="10";
  }

  const PAGES = [
    { kind:"TITLE", hint:"TAP ANYWHERE TO BEGIN" },
    { kind:"TR", lines:[
`Empathy originally refers to the ability to feel with others (共感).
In contemporary relational structures, however, this sense of togetherness has weakened,
shifting toward emptiness, disconnection, and absence (空).`,
"",
`This project begins at that point of rupture and explores whether emotions emptied of togetherness
can be reconstructed through cooking—the oldest bodily gesture of care.`,
"",
`Can the oldest gesture of care—cooking—restore emotions that have become empty of togetherness?`
    ], hint:"TAP ANYWHERE TO READ NEXT" },

    { kind:"BL", lines:[
`In contemporary society, empathy is often reduced to superficial reactions within accelerated communication.`,
"",
`Emotional connection weakens, leaving growing gaps between individuals.`,
"",
`This project treats that gap not as failure,
but as a starting point for reconstruction.`
    ], hint:"TAP ANYWHERE TO READ NEXT" },

    { kind:"TR", lines:[
`This performance-installation involves two artists who build an archive through remote workshops—recipes, memories, writing, and cooking videos—then translate it on-site into a miniature world (cooking table) and a live performance that shares shifting states of empathy (共感) with the audience.`,
"",
`The focus is not cooking itself, but the gesture—the subtle bodily vibration that emerges while following unfamiliar recipes, moving from estrangement to understanding and empathy.`
    ], hint:"TAP ANYWHERE TO READ NEXT" },

    { kind:"CENTER", lines:[
`WHY COOKING / WHY RECIPE`,
"",
`Cooking is both survival and a time-intensive gesture of care.
Recipes inherited from parents often embed personal emotional memory—nostalgia, longing, loss, attachment.
This project treats recipes as both an emotional document and a performance score,`,
"",
`testing how empathy can be reconstructed through exchanging, transforming, performing, and archiving them.`
    ], hint:"TAP ANYWHERE TO CONTINUE" },

    { kind:"CENTER", lines:[
`Now all explanations about the work are complete.`,
`Please freely walk through the exhibition space and watch the performance.`,
"",
`This program unfolds through taking photos.`,
`For explanations and participation methods for each performance,`,
`please press the HELP button at the top-left of the screen.`
    ], hint:"TAP ANYWHERE TO START COUNTDOWN" },

    { kind:"COUNTDOWN", lines:[`Enjoy the exhibition.`], hint:"STARTING IN 10" },
  ];

  let pageIndex = 0;
  let nodes = [];
  let lineIndex = 0;
  let locked = false;

  async function fadeSwap(renderFn){
    stage.classList.remove("show");
    await sleep(380);
    renderFn();
    await sleep(20);
    stage.classList.add("show");
  }

  function renderPage(){
    clearBlocks();
    const p = PAGES[pageIndex];
    tapHint.textContent = p.hint || "TAP ANYWHERE";

    if(p.kind==="TITLE"){
      blkTitle.style.display="block";
      nodes = [];
      lineIndex = 0;
      return;
    }

    if(p.kind==="TR"){
      blkTR.style.display="block";
      nodes = mountLines(linesTR, p.lines);
      lineIndex = 0;
      showLine(nodes, 0);
      return;
    }

    if(p.kind==="BL"){
      blkBL.style.display="block";
      nodes = mountLines(linesBL, p.lines);
      lineIndex = 0;
      showLine(nodes, 0);
      return;
    }

    if(p.kind==="CENTER"){
      blkCenter.style.display="block";
      nodes = mountLines(linesCenter, p.lines);
      lineIndex = 0;
      showLine(nodes, 0);
      return;
    }

    if(p.kind==="COUNTDOWN"){
      blkCenter.style.display="block";
      nodes = mountLines(linesCenter, p.lines);
      lineIndex = 0;
      showLine(nodes, 0);
      return;
    }
  }

  renderPage();

  async function onTap(){
    if(locked) return;
    locked = true;

    const p = PAGES[pageIndex];

    if(p.kind !== "TITLE" && p.kind !== "COUNTDOWN"){
      const next = lineIndex + 1;
      if(next < nodes.length){
        lineIndex = next;
        showLine(nodes, lineIndex);
        locked = false;
        return;
      }
    }

    if(p.kind === "COUNTDOWN"){
      countdownEl.classList.add("show");
      let n = 10;
      countdownEl.textContent = String(n);
      for(let i=0;i<10;i++){
        await sleep(1000);
        n--;
        countdownEl.textContent = String(n);
      }
      // 여기서 본편(카메라/트래킹)로 넘어가는 로직을 다시 붙이면 됨
      stage.classList.add("hidden");
      locked = false;
      return;
    }

    await fadeSwap(()=>{
      pageIndex = Math.min(PAGES.length-1, pageIndex+1);
      renderPage();
    });

    locked = false;
  }

  // ✅ iOS/Safari에서도 확실하게 먹도록 pointerdown + touchstart 둘 다
  stageTap.addEventListener('pointerdown', (e)=>{ e.preventDefault(); onTap(); }, {passive:false});
  stageTap.addEventListener('touchstart', (e)=>{ e.preventDefault(); onTap(); }, {passive:false});

  /* HELP panel */
  const helpBtn = qs('#helpBtn');
  const helpPanel = qs('#helpPanel');
  const helpClose = qs('#helpClose');
  helpBtn.addEventListener('click', ()=> helpPanel.classList.add('show'), {passive:true});
  helpClose.addEventListener('click', ()=> helpPanel.classList.remove('show'), {passive:true});
  helpPanel.addEventListener('click', (e)=>{ if(e.target===helpPanel) helpPanel.classList.remove('show'); }, {passive:true});
})();
</script>
</body>
</html>
